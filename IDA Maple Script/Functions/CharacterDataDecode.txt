unsigned __int64 __thiscall CharacterData::Decode(CharacterData *this, CInPacket *iPacket, int bBackwardUpdate)
{
  CharacterData *v3; // ebx
  _DWORD *v4; // ebx
  signed int v5; // edi
  DWORD v6; // eax
  ZList<long> *v7; // ebx
  int v8; // eax
  unsigned int v9; // edi
  int *v10; // eax
  bool v11; // zf
  signed int v12; // eax
  signed int v13; // edi
  char v14; // al
  int v15; // ebx
  char *v16; // eax
  unsigned int v17; // edi
  unsigned int v18; // eax
  int v19; // eax
  int v20; // edi
  GW_Core *v21; // edx
  signed int v22; // eax
  signed int v23; // edi
  GW_CharacterStat *v24; // edi
  ZXString<char> *v25; // eax
  char *v26; // ebx
  ZXString<char> *v27; // eax
  char *v28; // ebx
  ZXString<char> *v29; // eax
  char *v30; // ebx
  int v31; // ebx
  __int64 v32; // rax
  ZMap<long,GW_ExpConsumeItem,long> *v33; // edi
  signed int v34; // eax
  signed int v35; // ebx
  unsigned int v36; // eax
  _DWORD *v37; // esi
  int v38; // edi
  ZRef<MonsterBattle_MobInfo> *v39; // eax
  char *v40; // eax
  _DWORD *v41; // esi
  CInPacket *v42; // ebx
  unsigned int v43; // eax
  ZArray<ZRef<MonsterBattle_MobInfo> > *v44; // edi
  ZArray<ZRef<MonsterBattle_MobInfo> > v45; // eax
  unsigned int v46; // ebx
  int v47; // eax
  unsigned int v48; // eax
  int v49; // ebx
  int v50; // edi
  unsigned int v51; // edi
  int v52; // ebx
  int v53; // eax
  int v54; // eax
  void (__thiscall ***v55)(_DWORD, signed int); // esi
  volatile LONG *v56; // edi
  int v57; // eax
  void (__thiscall ***v58)(_DWORD, signed int); // esi
  volatile LONG *v59; // edi
  _DWORD *v60; // eax
  _DWORD *v61; // ecx
  signed int v62; // edx
  _DWORD *v63; // ecx
  signed int v64; // edx
  CInPacket *v65; // ebx
  _DWORD *v66; // esi
  _DWORD *v67; // esi
  signed int v68; // edi
  int v69; // eax
  ZArray<long> *v70; // esi
  char *v71; // eax
  unsigned int v72; // ebx
  int *v73; // eax
  unsigned int v74; // edi
  int v75; // eax
  unsigned int v76; // eax
  int v77; // edi
  unsigned int *v78; // eax
  GW_CharacterStat *v79; // ebx
  int v80; // eax
  void (__thiscall ***v81)(_DWORD, signed int); // esi
  volatile LONG *v82; // edi
  int v83; // eax
  void (__thiscall ***v84)(_DWORD, signed int); // esi
  volatile LONG *v85; // edi
  _DWORD *v86; // eax
  _DWORD *v87; // esi
  CInPacket *v88; // esi
  unsigned __int8 v89; // al
  int v90; // eax
  ZArray<GW_MonsterBattleRankInfo> *v91; // ebx
  char *v92; // eax
  GW_MonsterBattleRankInfo *v93; // eax
  unsigned int v94; // esi
  int v95; // eax
  unsigned int v96; // eax
  int v97; // esi
  GW_MonsterBattleRankInfo *v98; // edi
  int v99; // eax
  ZArray<GW_MonsterBattleRankInfo> *v100; // ebx
  char *v101; // eax
  GW_MonsterBattleRankInfo *v102; // eax
  unsigned int v103; // esi
  int v104; // eax
  unsigned int v105; // eax
  int v106; // esi
  GW_MonsterBattleRankInfo *v107; // edi
  int v108; // edi
  signed int v109; // ebx
  unsigned int v110; // eax
  CashItemEntry *v111; // ecx
  unsigned int v112; // esi
  unsigned int v113; // eax
  GW_ItemSlotBase *v114; // eax
  unsigned int v115; // esi
  int v116; // eax
  CashItemEntry *v117; // ecx
  unsigned int v118; // esi
  unsigned int v119; // eax
  GW_ItemSlotBase *v120; // eax
  unsigned int v121; // esi
  ZArray<ZRef<GW_ItemSlotBase> > *v122; // ebx
  int v123; // esi
  int v124; // edi
  GW_ItemSlotBase *v125; // ecx
  GW_ItemSlotBase *v126; // eax
  CashItemEntry *v127; // ecx
  unsigned int v128; // esi
  char *v129; // eax
  GW_ItemSlotBase *v130; // eax
  unsigned int v131; // esi
  bool v132; // sf
  unsigned __int8 v133; // of
  int v134; // esi
  signed int v135; // eax
  int v136; // eax
  int v137; // edx
  signed int v138; // ebx
  int v139; // eax
  int v140; // ecx
  unsigned int v141; // eax
  int v142; // eax
  _DWORD *v143; // edi
  unsigned int v144; // esi
  int v145; // eax
  unsigned int v146; // eax
  int v147; // esi
  int v148; // eax
  CashItemEntry *v149; // ecx
  CInPacket *v150; // edi
  ZArray<ZRef<GW_ItemSlotBase> > *v151; // esi
  int v152; // eax
  int v153; // ecx
  unsigned __int8 v154; // al
  ZArray<ZRef<GW_ItemSlotBase> > v155; // eax
  signed int v156; // eax
  signed int i; // ebx
  int v158; // eax
  int v159; // esi
  void (__stdcall ***v160)(signed int); // ecx
  unsigned int v161; // eax
  GW_CharacterStat *v162; // esi
  unsigned int *v163; // esi
  signed int v164; // ebx
  unsigned __int16 v165; // ax
  int v166; // esi
  CashItemEntry *v167; // eax
  unsigned __int16 v168; // ax
  int *v169; // esi
  signed int v170; // ebx
  unsigned __int16 v171; // ax
  int v172; // esi
  CashItemEntry *v173; // eax
  unsigned __int16 v174; // ax
  int v175; // eax
  unsigned __int16 v176; // ax
  signed int v177; // esi
  CashItemEntry *v178; // eax
  unsigned __int16 v179; // ax
  GW_CharacterStat *v180; // ebx
  unsigned __int64 v181; // rax
  int v182; // eax
  unsigned __int8 v183; // al
  signed int v184; // esi
  char *v185; // ebx
  CashItemEntry *v186; // eax
  unsigned __int8 v187; // al
  unsigned __int64 v188; // rax
  signed int v189; // ebx
  int j; // esi
  signed int v191; // ebx
  unsigned __int64 v192; // rax
  char *v193; // eax
  int v194; // ecx
  signed int v195; // eax
  BagData *v196; // esi
  int v197; // esi
  ZMap<long,_FILETIME,long> *v198; // esi
  signed int v199; // eax
  signed int v200; // ebx
  ZMap<unsigned __int64,_FILETIME,unsigned __int64> *v201; // esi
  signed int v202; // eax
  signed int v203; // ebx
  int v204; // eax
  void (__thiscall ***v205)(_DWORD, signed int); // esi
  volatile LONG *v206; // ebx
  unsigned __int8 v207; // bl
  GW_CharacterStat *v208; // esi
  unsigned __int16 v209; // ax
  int v210; // ebx
  ZMap<long,long,long> *v211; // esi
  char *v212; // esi
  std::map<long,long,std::less<long>,std::allocator<std::pair<long const ,long> > > *v213; // esi
  std::_Tree_nod<std::_Tmap_traits<long,long,std::less<long>,std::allocator<std::pair<long const ,long> >,0> >::_Node *v214; // eax
  char *v215; // eax
  int v216; // ebx
  int *v217; // eax
  int v218; // esi
  DiffZMap<long,long,long> *v219; // ebx
  int v220; // esi
  DiffZMap<long,long,long> *v221; // ebx
  int v222; // esi
  DiffZMap<long,_FILETIME,long> *v223; // ebx
  int v224; // esi
  DiffZMap<long,_FILETIME,long> *v225; // ebx
  int v226; // esi
  DiffZMap<long,long,long> *v227; // ebx
  int v228; // esi
  DiffZMap<long,long,long> *v229; // ebx
  CharacterData *v230; // ebx
  int k; // esi
  char v232; // al
  int v233; // eax
  int v234; // esi
  char *v235; // esi
  int v236; // esi
  int v237; // eax
  char v238; // al
  char *v239; // eax
  int v240; // esi
  int v241; // eax
  std::_Tree<std::_Tset_traits<long,std::less<long>,std::allocator<long>,0> > *v242; // esi
  int v243; // ebx
  unsigned int v244; // eax
  MONSTERLIFE_INVITEINFO *v245; // esi
  unsigned int v246; // eax
  GW_CharacterStat *v247; // ecx
  int v248; // esi
  int l; // esi
  int m; // esi
  int n; // esi
  ZList<GW_CoupleRecord> *v252; // ebx
  int ii; // esi
  GW_CoupleRecord *v254; // eax
  ZList<GW_FriendRecord> *v255; // ebx
  int jj; // esi
  GW_FriendRecord *v257; // eax
  ZList<GW_MarriageRecord> *v258; // ebx
  int kk; // esi
  GW_MarriageRecord *v260; // eax
  _DWORD *v261; // esi
  signed int v262; // ebx
  _DWORD *v263; // esi
  signed int v264; // ebx
  char *v265; // esi
  signed int v266; // ebx
  ZArray<CashItemEntry> *v267; // esi
  ZArray<CashItemEntry> *v268; // edi
  int v269; // ebx
  ZArray<CashItemEntry> v270; // eax
  int v271; // ecx
  int v272; // edx
  int v273; // ecx
  int v274; // ebx
  signed int v275; // eax
  signed int v276; // eax
  char *v277; // ebx
  signed int v278; // ebx
  ZArray<CashItemEntry> v279; // esi
  int v280; // eax
  GW_Core *v281; // edx
  int v282; // esi
  int v283; // esi
  int v284; // ebx
  signed int v285; // ebx
  int v286; // ebx
  char *v287; // esi
  CashItemEntry *v288; // ebx
  signed int v289; // esi
  CharacterData *v290; // edi
  ZArray<CashItemEntry> *v291; // esi
  char *v292; // esi
  int v293; // eax
  signed int v294; // ecx
  ZRef<GW_ItemSlotBase> *v295; // ecx
  signed int v296; // ecx
  ZRef<GW_ItemSlotBase> *v297; // eax
  int v298; // ecx
  signed int v299; // eax
  unsigned int v300; // esi
  int v301; // eax
  int v302; // eax
  CInPacket *v303; // edi
  unsigned __int16 v304; // ax
  GW_CharacterStat *v305; // ebx
  int v306; // esi
  char *v307; // esi
  __POSITION *v308; // eax
  char *v309; // esi
  int ll; // esi
  unsigned __int8 v311; // al
  int v312; // esi
  char *v313; // esi
  __POSITION *v314; // eax
  char *v315; // esi
  signed int mm; // esi
  GW_WildHunterInfo *v317; // eax
  $71D4F1BB3D693B543BB6351DD48CDF34 *v318; // esi
  int v319; // eax
  unsigned __int16 v320; // ax
  int v321; // esi
  unsigned int v322; // eax
  unsigned int v323; // esi
  int v324; // esi
  unsigned __int16 v325; // ax
  int v326; // esi
  char *v327; // esi
  volatile LONG *v328; // ebx
  signed int v329; // esi
  _DWORD *v330; // eax
  char *v331; // eax
  GW_CharacterPotentialSkill *v332; // eax
  __int16 v333; // cx
  char v334; // dl
  char *v335; // eax
  MONSTERLIFE_INVITEINFO *v336; // esi
  _DWORD *v337; // eax
  char *v338; // eax
  ZXString<char> *v339; // eax
  void *v340; // esi
  MONSTERLIFE_INVITEINFO *v341; // esi
  char *v342; // eax
  ZRef<MONSTERLIFE_INVITEINFO> *v343; // eax
  int v344; // esi
  char *v345; // esi
  char v346; // al
  char v347; // si
  unsigned __int16 v348; // bx
  int v349; // esi
  int v350; // ebx
  int v351; // eax
  int v352; // esi
  int v353; // eax
  char v354; // si
  CharacterData *v355; // ebx
  int v356; // eax
  ZRef<GW_Core> *v357; // eax
  int v358; // esi
  int v359; // esi
  char *v360; // eax
  int v361; // eax
  GW_Core *v362; // esi
  char *v363; // eax
  int v364; // eax
  GW_Core *v365; // esi
  int v366; // esi
  GW_CharacterStat *v367; // ebx
  unsigned int v368; // eax
  ZMap<long,CSimpleStrMap,long> *v369; // ebx
  int v370; // esi
  char *v371; // esi
  __POSITION *v372; // eax
  char *v373; // esi
  ZMap<long,CSimpleStrMap,long> *v374; // ebx
  int v375; // esi
  char *v376; // esi
  __POSITION *v377; // eax
  char *v378; // esi
  CharacterData *v379; // esi
  char v380; // al
  char *v382; // [esp+38h] [ebp-238h]
  void *v383[6]; // [esp+3Ch] [ebp-234h]
  ZXString<char> sValue; // [esp+54h] [ebp-21Ch]
  GW_ItemSlotBase *v385; // [esp+58h] [ebp-218h]
  GW_CharacterStat *v386; // [esp+5Ch] [ebp-214h]
  bool v387; // [esp+63h] [ebp-20Dh]
  int nCount; // [esp+64h] [ebp-20Ch]
  GW_ItemSlotBase *v389; // [esp+68h] [ebp-208h]
  int nTI; // [esp+6Ch] [ebp-204h]
  ZRef<MONSTERLIFE_INVITEINFO> pInfo; // [esp+70h] [ebp-200h]
  unsigned __int64 dbcharFlag; // [esp+78h] [ebp-1F8h]
  int nSlot4; // [esp+84h] [ebp-1ECh]
  int nSlot2; // [esp+88h] [ebp-1E8h]
  BagData *v395; // [esp+8Ch] [ebp-1E4h]
  ZXString<char> sKey; // [esp+90h] [ebp-1E0h]
  int v397; // [esp+94h] [ebp-1DCh]
  ZRef<GW_Core> pCore; // [esp+98h] [ebp-1D8h]
  int nSlotHyper; // [esp+A0h] [ebp-1D0h]
  int nKey; // [esp+A4h] [ebp-1CCh]
  ZArray<CashItemEntry> aaCashItem1[6]; // [esp+A8h] [ebp-1C8h]
  ZArray<CashItemEntry> aaCashItem2[6]; // [esp+C0h] [ebp-1B0h]
  int v403; // [esp+D8h] [ebp-198h]
  int v404; // [esp+DCh] [ebp-194h]
  AvatarLook value; // [esp+E0h] [ebp-190h]
  BuyLimitData dummyBLD; // [esp+228h] [ebp-48h]
  char v407; // [esp+258h] [ebp-18h]
  int v408; // [esp+26Ch] [ebp-4h]

  v3 = this;
  v386 = &this->characterStat;
  nSlotHyper = (int)iPacket;
  CInPacket::DecodeBuffer(iPacket, &dbcharFlag, 8u);
  v3->nCombatOrders = (unsigned __int8)CInPacket::Decode1(iPacket);
  v4 = v3->aPetActiveSkillCoolTime;
  nKey = 3;
  do
  {
    v5 = CInPacket::Decode4(iPacket);
    v6 = timeGetTime();
    if ( v5 > 0 )
      v6 += v5;
    *v4 = v6;
    ++v4;
    --nKey;
  }
  while ( nKey );
  v7 = (ZList<long> *)&v386[2]._ZtlSecureTear_nPvPExp_CS;
  ZList<long>::RemoveAll((ZList<long> *)&v386[2]._ZtlSecureTear_nPvPExp_CS);
  v8 = (unsigned __int8)CInPacket::Decode1(iPacket);
  if ( (signed int)(unsigned __int8)v8 > 0 )
  {
    nKey = v8;
    do
    {
      v9 = CInPacket::Decode4(iPacket);
      v10 = ZList<long>::AddTail(v7);
      v11 = nKey-- == 1;
      *v10 = v9;
    }
    while ( !v11 );
  }
  v12 = CInPacket::Decode4(iPacket);
  if ( v12 > 0 )
  {
    v13 = v12;
    do
    {
      nKey = CInPacket::Decode4(iPacket);
      pInfo = (ZRef<MONSTERLIFE_INVITEINFO>)DB_DATE_20790101_46;
      CInPacket::DecodeBuffer(iPacket, &pInfo, 8u);
      ZMap<long,_FILETIME,long>::Insert(
        (ZMap<long,_FILETIME,long> *)((char *)&v386[2]._ZtlSecureTear_nWillEXP[1] + 1),
        &nKey,
        (_FILETIME *)&pInfo);
      --v13;
    }
    while ( v13 );
  }
  v14 = CInPacket::Decode1(iPacket);
  v15 = 0;
  nKey = 0;
  v408 = 0;
  if ( v14 )
  {
    CInPacket::Decode1(iPacket);
    v16 = (char *)CInPacket::Decode4(iPacket);
    if ( (signed int)v16 > 0 )
    {
      sValue._m_pStr = v16;
      do
      {
        CInPacket::DecodeBuffer(iPacket, &pCore, 8u);
        if ( v15 )
        {
          v19 = *(_DWORD *)(v15 - 8);
          v17 = *(_DWORD *)(v15 - 4);
          if ( v19 < 0 )
            v19 = ~v19;
          if ( (unsigned int)(v19 - 4) >> 3 > v17 )
            goto LABEL_23;
          if ( v17 )
            v18 = 2 * v17;
          else
            v18 = 1;
        }
        else
        {
          v17 = 0;
          v18 = 1;
        }
        ZArray<_LARGE_INTEGER>::_Reserve((ZArray<_LARGE_INTEGER> *)&nKey, v18, (ZAllocHelper *)&v387);
        v15 = nKey;
LABEL_23:
        ++*(_DWORD *)(v15 - 4)
        v20 = v15 + 8 * v17;
        memmove((char *)(v20 + 8), (char *)v20, 0);
        v21 = pCore.p;
        v11 = sValue._m_pStr-- == (char *)1;
        *(_DWORD *)v20 = *(_DWORD *)pCore.gap0;
        *(_DWORD *)(v20 + 4) = v21;
      }
      while ( !v11 );
    }
    v22 = CInPacket::Decode4(iPacket);
    if ( v22 > 0 )
    {
      v23 = v22;
      do
      {
        CInPacket::DecodeBuffer(iPacket, &pCore, 8u);
        --v23;
      }
      while ( v23 );
    }
  }
  v24 = v386;
  if ( dbcharFlag & 1 )
  {
    GW_CharacterStat::Decode(v386, iPacket, bBackwardUpdate);
    *(int *)((char *)v386[3]._ZtlSecureTear_nPvPExp + 3) = (unsigned __int8)CInPacket::Decode1(iPacket);
    if ( CInPacket::Decode1(iPacket) )
    {
      v25 = CInPacket::DecodeStr(iPacket, &sValue);
      LOBYTE(v408) = 1;
      ZXString<char>::operator=((ZXString<char> *)((char *)&v24[4]._ZtlSecureTear_nLevel_CS + 2), v25);
      LOBYTE(v408) = 0;
      if ( sValue._m_pStr )
      {
        v26 = sValue._m_pStr - 12;
        if ( InterlockedDecrement((volatile LONG *)sValue._m_pStr - 3) <= 0 )
          ZAllocEx<ZAllocStrSelector<char>>::Free(&ZAllocEx<ZAllocStrSelector<char>>::_s_alloc, v26);
      }
    }
    if ( CInPacket::Decode1(iPacket) )
    {
      v27 = CInPacket::DecodeStr(iPacket, &sValue);
      LOBYTE(v408) = 2;
      ZXString<char>::operator=((ZXString<char> *)&v24[4]._ZtlSecureTear_nJob[1], v27);
      LOBYTE(v408) = 0;
      if ( sValue._m_pStr )
      {
        v28 = sValue._m_pStr - 12;
        if ( InterlockedDecrement((volatile LONG *)sValue._m_pStr - 3) <= 0 )
          ZAllocEx<ZAllocStrSelector<char>>::Free(&ZAllocEx<ZAllocStrSelector<char>>::_s_alloc, v28);
      }
    }
    if ( CInPacket::Decode1(iPacket) )
    {
      v29 = CInPacket::DecodeStr(iPacket, &sValue);
      LOBYTE(v408) = 3;
      ZXString<char>::operator=((ZXString<char> *)((char *)&v24[4]._ZtlSecureTear_nJob_CS + 2), v29);
      LOBYTE(v408) = 0;
      if ( sValue._m_pStr )
      {
        v30 = sValue._m_pStr - 12;
        if ( InterlockedDecrement((volatile LONG *)sValue._m_pStr - 3) <= 0 )
          ZAllocEx<ZAllocStrSelector<char>>::Free(&ZAllocEx<ZAllocStrSelector<char>>::_s_alloc, v30);
      }
    }
  }
  v31 = dbcharFlag;
  if ( dbcharFlag & 2 )
  {
    v32 = CInPacket::Decode8(iPacket);
    v24->_ZtlSecureTear_nMoney_CS = _ZtlSecureTear<__int64>(v32, v24->_ZtlSecureTear_nMoney);
  }
  if ( v31 & 8 || v31 & 0x2000000 )
  {
    v33 = (ZMap<long,GW_ExpConsumeItem,long> *)((char *)&v24[2].dwPosMap.FakePtr2 + 1);
    ZMap<long,GW_ExpConsumeItem,long>::RemoveAll(v33);
    v34 = CInPacket::Decode4(iPacket);
    if ( v34 > 0 )
    {
      v35 = v34;
      do
      {
        dummyBLD.dwNPCID = CInPacket::Decode4(iPacket);
        *(_DWORD *)&dummyBLD.nItemIndex = CInPacket::Decode4(iPacket);
        *(int *)((char *)&dummyBLD.nItemID + 2) = CInPacket::Decode4(iPacket);
        *(_QWORD *)((char *)&dummyBLD.nCount + 2) = CInPacket::Decode8(iPacket);
        ZMap<long,GW_ExpConsumeItem,long>::Insert(v33, (const int *)&dummyBLD, (GW_ExpConsumeItem *)&dummyBLD);
        --v35;
      }
      while ( v35 );
    }
  }
  if ( dbcharFlag & 0x800000000000i64 )
  {
    v36 = CInPacket::Decode4((CInPacket *)nSlotHyper);
    v37 = (unsigned int *)((char *)&v386[5]._ZtlSecureTear_nMoney_CS + 1);
    v38 = v36;
    v39 = *(ZRef<MonsterBattle_MobInfo> **)((char *)&v386[5]._ZtlSecureTear_nMoney_CS + 1);
    if ( v39 )
    {
      ZArray<ZRef<MonsterBattle_MobInfo>>::_Destroy(v39, &v39[(_DWORD)v39[-1].p]);
      ZAllocEx<ZAllocAnonSelector>::Free(&ZAllocEx<ZAllocAnonSelector>::_s_alloc, (void *)(*v37 - 4));
      *v37 = 0;
    }
    if ( v38 > 0 )
    {
      nCount = v38;
      do
      {
        v40 = (char *)ZRecyclableAvBuffer<ZRefCountedDummy<MonsterBattle_MobInfo>,16,MonsterBattle_MobInfo>::raw_new(ZRecyclableAvBuffer<ZRefCountedDummy<MonsterBattle_MobInfo>,16,MonsterBattle_MobInfo>::s_pInstance);
        if ( v40 )
        {
          *((_DWORD *)v40 + 1) = 0;
          *((_DWORD *)v40 + 2) = 0;
          *((_DWORD *)v40 + 3) = &ZRecyclable<ZRefCountedDummy<MonsterBattle_MobInfo>,16,MonsterBattle_MobInfo>::`vftable';
          *(_DWORD *)v40 = &ZRefCountedDummy<MonsterBattle_MobInfo>::`vftable'{for `ZRefCounted'};
          *((_DWORD *)v40 + 3) = &ZRefCountedDummy<MonsterBattle_MobInfo>::`vftable'{for `ZRecyclable<ZRefCountedDummy<MonsterBattle_MobInfo>,16,MonsterBattle_MobInfo>'};
          *((_DWORD *)v40 + 4) = 0;
          *((_DWORD *)v40 + 5) = 1;
          *((_DWORD *)v40 + 6) = 0;
          *((_DWORD *)v40 + 7) = 0;
          *((_DWORD *)v40 + 8) = 0;
          *((_DWORD *)v40 + 9) = 0;
          *((_DWORD *)v40 + 10) = 0;
          *((_DWORD *)v40 + 11) = 0;
          *((_DWORD *)v40 + 12) = -1;
        }
        else
        {
          v40 = 0;
        }
        v41 = v40 + 16;
        *((_DWORD *)v40 + 1) = 1;
        pCore.p = (GW_Core *)(v40 + 16);
        v42 = (CInPacket *)nSlotHyper;
        LOBYTE(v408) = 4;
        *v41 = CInPacket::Decode4((CInPacket *)nSlotHyper);
        v41[1] = CInPacket::Decode4(v42);
        v41[2] = CInPacket::Decode4(v42);
        v41[3] = CInPacket::Decode4(v42);
        v41[4] = CInPacket::Decode4(v42);
        v41[5] = CInPacket::Decode4(v42);
        v41[6] = (unsigned __int8)CInPacket::Decode1(v42);
        v41[7] = CInPacket::Decode4(v42);
        v43 = CInPacket::Decode4(v42);
        v44 = (ZArray<ZRef<MonsterBattle_MobInfo> > *)((char *)&v386[5]._ZtlSecureTear_nMoney_CS + 1);
        v41[8] = v43;
        v45.a = v44->a;
        if ( v44->a )
          v46 = (unsigned int)v45.a[-1].p;
        else
          v46 = 0;
        if ( !v45.a )
          goto LABEL_708;
        v47 = *(_DWORD *)v45.a[-1].gap0;
        if ( v47 < 0 )
          v47 = ~v47;
        if ( (unsigned int)(v47 - 4) >> 3 <= v46 )
        {
LABEL_708:
          v48 = 1;
          if ( v46 )
            v48 = 2 * v46;
          ZArray<ZRef<MonsterBattle_MobInfo>>::_Reserve(v44, v48, (ZAllocHelper *)&v387);
        }
        ++v44->a[-1].p;
        v49 = v46;
        memmove(v44->a[v49 + 1].gap0, v44->a[v49].gap0, 0);
        v50 = (int)&v44->a[v49];
        if ( v50 )
          *(_DWORD *)(v50 + 4) = 0;
        v51 = v49 * 8 + *(unsigned int *)((char *)&v386[5]._ZtlSecureTear_nMoney_CS + 1);
        v52 = (int)(v41 - 4);
        InterlockedIncrement(v41 - 3);
        v53 = *(_DWORD *)(v51 + 4);
        if ( v53 )
        {
          sValue._m_pStr = (char *)(v53 - 16);
          if ( !InterlockedDecrement((volatile LONG *)(v53 - 16 + 4)) )
          {
            InterlockedIncrement((volatile LONG *)sValue._m_pStr + 1);
            if ( sValue._m_pStr )
              (**(void (__stdcall ***)(signed int))sValue._m_pStr)(1);
          }
          *(_DWORD *)(v51 + 4) = 0;
        }
        *(_DWORD *)(v51 + 4) = v41;
        LOBYTE(v408) = 0;
        if ( !InterlockedDecrement((volatile LONG *)(v52 + 4)) )
        {
          InterlockedIncrement((volatile LONG *)(v52 + 4));
          if ( v41 != (_DWORD *)16 )
            (**(void (__thiscall ***)(int, signed int))v52)(v52, 1);
        }
        v11 = nCount-- == 1;
        pCore.p = 0;
      }
      while ( !v11 );
    }
    v54 = *(_DWORD *)((char *)&v386[5]._ZtlSecureTear_nMoney[1] + 1);
    if ( v54 )
    {
      v55 = (void (__thiscall ***)(_DWORD, signed int))(v54 - 16);
      v56 = (volatile LONG *)(v54 - 16 + 4);
      if ( !InterlockedDecrement(v56) )
      {
        InterlockedIncrement(v56);
        if ( v55 )
          (**v55)(v55, 1);
      }
      *(_DWORD *)((char *)&v386[5]._ZtlSecureTear_nMoney[1] + 1) = 0;
    }
    v57 = *(_DWORD *)((char *)&v386[5]._ZtlSecureTear_nMoney[1] + 1);
    if ( v57 )
    {
      v58 = (void (__thiscall ***)(_DWORD, signed int))(v57 - 16);
      v59 = (volatile LONG *)(v57 - 16 + 4);
      if ( !InterlockedDecrement(v59) )
      {
        InterlockedIncrement(v59);
        if ( v58 )
          (**v58)(v58, 1);
      }
      *(_DWORD *)((char *)&v386[5]._ZtlSecureTear_nMoney[1] + 1) = 0;
    }
    v60 = ZRecyclableAvBuffer<ZRefCountedDummy<MonsterBattle_MobSkillSlot>,16,MonsterBattle_MobSkillSlot>::raw_new(ZRecyclableAvBuffer<ZRefCountedDummy<MonsterBattle_MobSkillSlot>,16,MonsterBattle_MobSkillSlot>::s_pInstance);
    if ( v60 )
    {
      v60[1] = 0;
      v60[2] = 0;
      v60[3] = &ZRecyclable<ZRefCountedDummy<MonsterBattle_MobSkillSlot>,16,MonsterBattle_MobSkillSlot>::`vftable';
      *v60 = &ZRefCountedDummy<MonsterBattle_MobSkillSlot>::`vftable'{for `ZRefCounted'};
      v60[3] = &ZRefCountedDummy<MonsterBattle_MobSkillSlot>::`vftable'{for `ZRecyclable<ZRefCountedDummy<MonsterBattle_MobSkillSlot>,16,MonsterBattle_MobSkillSlot>'};
      v61 = v60 + 5;
      v62 = 2;
      do
      {
        v61[1] = 0;
        *v61 = 0;
        v61 += 2;
        --v62;
      }
      while ( v62 >= 0 );
      v60[4] = 0;
      v63 = v60 + 5;
      v64 = 3;
      do
      {
        v63[1] = 0;
        *v63 = 0;
        v63 += 2;
        --v64;
      }
      while ( v64 );
    }
    else
    {
      v60 = 0;
    }
    v65 = (CInPacket *)nSlotHyper;
    v60[1] = 1;
    *(_DWORD *)((char *)&v386[5]._ZtlSecureTear_nMoney[1] + 1) = v60 + 4;
    v66 = v60 + 4;
    *v66 = CInPacket::Decode4(v65);
    v67 = v66 + 2;
    v68 = 3;
    do
    {
      *(v67 - 1) = CInPacket::Decode4(v65);
      *v67 = CInPacket::Decode4(v65);
      v67 += 2;
      --v68;
    }
    while ( v68 );
    v69 = *(_DWORD *)((char *)&v386[5]._ZtlSecureTear_nMoney[1] + 5);
    v70 = (ZArray<long> *)((char *)&v386[5]._ZtlSecureTear_nMoney[1] + 5);
    if ( v69 )
    {
      ZAllocEx<ZAllocAnonSelector>::Free(&ZAllocEx<ZAllocAnonSelector>::_s_alloc, (void *)(v69 - 4));
      v70->a = 0;
    }
    v71 = (char *)CInPacket::Decode4(v65);
    if ( (signed int)v71 > 0 )
    {
      sValue._m_pStr = v71;
      do
      {
        v72 = CInPacket::Decode4((CInPacket *)nSlotHyper);
        v73 = v70->a;
        if ( v70->a )
          v74 = *(v73 - 1);
        else
          v74 = 0;
        if ( !v73 )
          goto LABEL_709;
        v75 = *(v73 - 2);
        if ( v75 < 0 )
          v75 = ~v75;
        if ( (unsigned int)(v75 - 4) >> 2 <= v74 )
        {
LABEL_709:
          v76 = 1;
          if ( v74 )
            v76 = 2 * v74;
          ZArray<long>::_Reserve(v70, v76, (ZAllocHelper *)&v387);
        }
        ++*(v70->a - 1);
        v77 = v74;
        memmove((char *)&v70->a[v77 + 1], (char *)&v70->a[v77], 0);
        v78 = (unsigned int *)&v70->a[v77];
        v11 = sValue._m_pStr-- == (char *)1;
        *v78 = v72;
      }
      while ( !v11 );
    }
    v79 = v386;
    v80 = *(_DWORD *)((char *)v386[5]._ZtlSecureTear_nMoney + 1);
    if ( v80 )
    {
      v81 = (void (__thiscall ***)(_DWORD, signed int))(v80 - 16);
      v82 = (volatile LONG *)(v80 - 16 + 4);
      if ( !InterlockedDecrement(v82) )
      {
        InterlockedIncrement(v82);
        if ( v81 )
          (**v81)(v81, 1);
      }
      *(_DWORD *)((char *)v79[5]._ZtlSecureTear_nMoney + 1) = 0;
    }
    v83 = *(_DWORD *)((char *)v79[5]._ZtlSecureTear_nMoney + 1);
    if ( v83 )
    {
      v84 = (void (__thiscall ***)(_DWORD, signed int))(v83 - 16);
      v85 = (volatile LONG *)(v83 - 16 + 4);
      if ( !InterlockedDecrement(v85) )
      {
        InterlockedIncrement(v85);
        if ( v84 )
          (**v84)(v84, 1);
      }
      *(_DWORD *)((char *)v79[5]._ZtlSecureTear_nMoney + 1) = 0;
    }
    v86 = ZRecyclableAvBuffer<ZRefCountedDummy<GW_MonsterBattleLadder_UserInfo>,16,GW_MonsterBattleLadder_UserInfo>::raw_new(ZRecyclableAvBuffer<ZRefCountedDummy<GW_MonsterBattleLadder_UserInfo>,16,GW_MonsterBattleLadder_UserInfo>::s_pInstance);
    v87 = v86;
    if ( v86 )
    {
      v86[1] = 0;
      v86[2] = 0;
      v383[1] = (void *)60;
      v86[3] = &ZRecyclable<ZRefCountedDummy<GW_MonsterBattleLadder_UserInfo>,16,GW_MonsterBattleLadder_UserInfo>::`vftable';
      v383[0] = 0;
      v382 = (char *)(v86 + 4);
      *v86 = &ZRefCountedDummy<GW_MonsterBattleLadder_UserInfo>::`vftable'{for `ZRefCounted'};
      v86[3] = &ZRefCountedDummy<GW_MonsterBattleLadder_UserInfo>::`vftable'{for `ZRecyclable<ZRefCountedDummy<GW_MonsterBattleLadder_UserInfo>,16,GW_MonsterBattleLadder_UserInfo>'};
      memset(v382, (char)v383[0], (unsigned int)v383[1]);
    }
    else
    {
      v87 = 0;
    }
    v87[1] = 1;
    *(_DWORD *)((char *)v79[5]._ZtlSecureTear_nMoney + 1) = v87 + 4;
    v88 = (CInPacket *)nSlotHyper;
    v89 = CInPacket::Decode1((CInPacket *)nSlotHyper);
    *(int *)((char *)v79[5]._ZtlSecureTear_nPOP + 1) = v89;
    if ( v89 )
      GW_MonsterBattleLadder_UserInfo::Decode(
        *(GW_MonsterBattleLadder_UserInfo **)((char *)v79[5]._ZtlSecureTear_nMoney + 1),
        v88);
    v90 = *(int *)((char *)v79[5]._ZtlSecureTear_nWP + 1);
    v91 = (ZArray<GW_MonsterBattleRankInfo> *)((char *)v79[5]._ZtlSecureTear_nWP + 1);
    if ( v90 )
    {
      ZAllocEx<ZAllocAnonSelector>::Free(&ZAllocEx<ZAllocAnonSelector>::_s_alloc, (void *)(v90 - 4));
      v91->a = 0;
    }
    v92 = (char *)(unsigned __int8)CInPacket::Decode1(v88);
    if ( (signed int)(unsigned __int8)v92 > 0 )
    {
      sValue._m_pStr = v92;
      do
      {
        GW_MonsterBattleRankInfo::Decode((GW_MonsterBattleRankInfo *)&dummyBLD, (CInPacket *)nSlotHyper);
        v93 = v91->a;
        if ( v91->a )
          v94 = *(_DWORD *)&v93[-1].sCharacterName[9];
        else
          v94 = 0;
        if ( !v93 )
          goto LABEL_710;
        v95 = *(_DWORD *)&v93[-1].sCharacterName[5];
        if ( v95 < 0 )
          v95 = ~v95;
        if ( (v95 - 4) / 0x31u <= v94 )
        {
LABEL_710:
          v96 = 1;
          if ( v94 )
            v96 = 2 * v94;
          ZArray<GW_MonsterBattleRankInfo>::_Reserve(v91, v96, (ZAllocHelper *)&v387);
        }
        v97 = v94;
        ++*(_DWORD *)&v91->a[-1].sCharacterName[9];
        memmove((char *)&v91->a[v97 + 1], (char *)&v91->a[v97], 0);
        v98 = &v91->a[v97];
        qmemcpy(v98, &dummyBLD, 0x30u);
        v11 = sValue._m_pStr-- == (char *)1;
        v98->sCharacterName[12] = v407;
      }
      while ( !v11 );
    }
    v99 = *(int *)((char *)&v386[5]._ZtlSecureTear_nWP[1] + 1);
    v100 = (ZArray<GW_MonsterBattleRankInfo> *)((char *)&v386[5]._ZtlSecureTear_nWP[1] + 1);
    if ( v99 )
    {
      ZAllocEx<ZAllocAnonSelector>::Free(&ZAllocEx<ZAllocAnonSelector>::_s_alloc, (void *)(v99 - 4));
      v100->a = 0;
    }
    v101 = (char *)(unsigned __int8)CInPacket::Decode1((CInPacket *)nSlotHyper);
    if ( (signed int)(unsigned __int8)v101 > 0 )
    {
      sValue._m_pStr = v101;
      do
      {
        GW_MonsterBattleRankInfo::Decode((GW_MonsterBattleRankInfo *)&dummyBLD, (CInPacket *)nSlotHyper);
        v102 = v100->a;
        if ( v100->a )
          v103 = *(_DWORD *)&v102[-1].sCharacterName[9];
        else
          v103 = 0;
        if ( !v102 )
          goto LABEL_711;
        v104 = *(_DWORD *)&v102[-1].sCharacterName[5];
        if ( v104 < 0 )
          v104 = ~v104;
        if ( (v104 - 4) / 0x31u <= v103 )
        {
LABEL_711:
          v105 = 1;
          if ( v103 )
            v105 = 2 * v103;
          ZArray<GW_MonsterBattleRankInfo>::_Reserve(v100, v105, (ZAllocHelper *)&v387);
        }
        v106 = v103;
        ++*(_DWORD *)&v100->a[-1].sCharacterName[9];
        memmove((char *)&v100->a[v106 + 1], (char *)&v100->a[v106], 0);
        v107 = &v100->a[v106];
        qmemcpy(v107, &dummyBLD, 0x30u);
        v11 = sValue._m_pStr-- == (char *)1;
        v107->sCharacterName[12] = v407;
      }
      while ( !v11 );
    }
  }
  `eh vector constructor iterator'(
    aaCashItem1,
    4u,
    6,
    (void (__thiscall *)(void *))ZArray<CashItemEntry>::ZArray<CashItemEntry>,
    (void (__thiscall *)(void *))ZArray<CashItemEntry>::~ZArray<CashItemEntry>);
  LOBYTE(v408) = 5;
  `eh vector constructor iterator'(
    aaCashItem2,
    4u,
    6,
    (void (__thiscall *)(void *))ZArray<CashItemEntry>::ZArray<CashItemEntry>,
    (void (__thiscall *)(void *))ZArray<CashItemEntry>::~ZArray<CashItemEntry>);
  v108 = 0;
  LOBYTE(v408) = 6;
  if ( bBackwardUpdate )
  {
    if ( dbcharFlag & 4 )
    {
      v109 = -1;
      nCount = (int)&v386[1]._ZtlSecureTear_nCharismaEXP_CS;
      while ( 1 )
      {
        v110 = *(_DWORD *)(nCount - 256);
        if ( !v110 || !*(_QWORD *)(v110 + 24) )
          goto LABEL_174;
        sValue._m_pStr = (char *)&v382;
        *(_QWORD *)v383 = __PAIR__(v109, v110);
        if ( v110 )
          InterlockedIncrement((volatile LONG *)(v110 + 4));
        v111 = aaCashItem1[1].a;
        LOBYTE(v408) = 7;
        if ( aaCashItem1[1].a )
        {
          v114 = aaCashItem1[1].a[-1].pItem.p;
          v112 = aaCashItem1[1].a[-1].nPOS;
          if ( (signed int)v114 < 0 )
            v114 = (GW_ItemSlotBase *)~(unsigned int)v114;
          if ( (unsigned int)&v114[-1].nBagIndex / 0xC > v112 )
            goto LABEL_171;
          if ( v112 )
            v113 = 2 * v112;
          else
            v113 = 1;
        }
        else
        {
          v112 = 0;
          v113 = 1;
        }
        ZArray<CashItemEntry>::_Reserve(&aaCashItem1[1], v113, (ZAllocHelper *)&v387);
        v111 = aaCashItem1[1].a;
LABEL_171:
        ++v111[-1].nPOS;
        v115 = v112;
        memmove(aaCashItem1[1].a[v115 + 1].pItem.gap0, aaCashItem1[1].a[v115].pItem.gap0, 0);
        if ( &aaCashItem1[1].a[v115] )
          aaCashItem1[1].a[v115].pItem.p = 0;
        LOBYTE(v408) = 6;
        CashItemEntry::Set(&aaCashItem1[1].a[v115], *(ZRef<GW_ItemSlotBase> *)&v382, (int)v383[1]);
LABEL_174:
        v116 = *(_DWORD *)nCount;
        if ( *(_DWORD *)nCount && *(_QWORD *)(v116 + 24) )
        {
          v383[1] = (void *)(v109 - 100);
          sValue._m_pStr = (char *)&v382;
          v383[0] = (void *)v116;
          if ( v116 )
            InterlockedIncrement((volatile LONG *)(v116 + 4));
          v117 = aaCashItem1[1].a;
          LOBYTE(v408) = 8;
          if ( !aaCashItem1[1].a )
          {
            v118 = 0;
            v119 = 1;
            goto LABEL_186;
          }
          v120 = aaCashItem1[1].a[-1].pItem.p;
          v118 = aaCashItem1[1].a[-1].nPOS;
          if ( (signed int)v120 < 0 )
            v120 = (GW_ItemSlotBase *)~(unsigned int)v120;
          if ( (unsigned int)&v120[-1].nBagIndex / 0xC <= v118 )
          {
            if ( v118 )
              v119 = 2 * v118;
            else
              v119 = 1;
LABEL_186:
            ZArray<CashItemEntry>::_Reserve(&aaCashItem1[1], v119, (ZAllocHelper *)&v387);
            v117 = aaCashItem1[1].a;
          }
          ++v117[-1].nPOS;
          v121 = v118;
          memmove(aaCashItem1[1].a[v121 + 1].pItem.gap0, aaCashItem1[1].a[v121].pItem.gap0, 0);
          if ( &aaCashItem1[1].a[v121] )
            aaCashItem1[1].a[v121].pItem.p = 0;
          LOBYTE(v408) = 6;
          CashItemEntry::Set(&aaCashItem1[1].a[v121], *(ZRef<GW_ItemSlotBase> *)&v382, (int)v383[1]);
        }
        nCount += 8;
        if ( --v109 < -31 )
        {
          nCount = 0;
          v122 = (ZArray<ZRef<GW_ItemSlotBase> > *)&v386[1].characterCard.card[7];
          while ( 1 )
          {
            if ( nCount == 2 || nCount == 3 || nCount == 5 )
            {
              v123 = NonBPEquip::anBasePOS[nCount];
              v124 = 0;
              if ( ZArray<ZRef<GW_ItemSlotBase>>::GetCount(v122) )
                break;
            }
LABEL_214:
            ++v122;
            v133 = __OFSUB__(nCount + 1, 7);
            v132 = nCount++ - 6 < 0;
            if ( !(v132 ^ v133) )
            {
              v108 = 0;
              goto LABEL_216;
            }
          }
          sValue._m_pStr = (char *)-v123;
          while ( 2 )
          {
            v125 = v122->a[v124].p;
            if ( v125 && v125->liCashItemSN.QuadPart )
            {
              v126 = v122->a[v124].p;
              nSlot2 = (int)&v382;
              *(_QWORD *)v383 = __PAIR__((unsigned int)sValue._m_pStr, (unsigned int)v126);
              if ( v126 )
                InterlockedIncrement(&v126->_m_nRef);
              v127 = aaCashItem1[1].a;
              LOBYTE(v408) = 9;
              if ( !aaCashItem1[1].a )
              {
                v128 = 0;
                v129 = &aaCashItem1[1].a->pItem.gap0[1];
                goto LABEL_209;
              }
              v130 = aaCashItem1[1].a[-1].pItem.p;
              v128 = aaCashItem1[1].a[-1].nPOS;
              if ( (signed int)v130 < 0 )
                v130 = (GW_ItemSlotBase *)~(unsigned int)v130;
              if ( (unsigned int)&v130[-1].nBagIndex / 0xC <= v128 )
              {
                if ( v128 )
                  v129 = (char *)(2 * v128);
                else
                  v129 = (char *)1;
LABEL_209:
                ZArray<CashItemEntry>::_Reserve(&aaCashItem1[1], (unsigned int)v129, (ZAllocHelper *)&v387);
                v127 = aaCashItem1[1].a;
              }
              ++v127[-1].nPOS;
              v131 = v128;
              memmove(aaCashItem1[1].a[v131 + 1].pItem.gap0, aaCashItem1[1].a[v131].pItem.gap0, 0);
              if ( &aaCashItem1[1].a[v131] )
                aaCashItem1[1].a[v131].pItem.p = 0;
              LOBYTE(v408) = 6;
              CashItemEntry::Set(&aaCashItem1[1].a[v131], *(ZRef<GW_ItemSlotBase> *)&v382, (int)v383[1]);
            }
            --sValue._m_pStr;
            if ( ++v124 >= ZArray<ZRef<GW_ItemSlotBase>>::GetCount(v122) )
              goto LABEL_214;
            continue;
          }
        }
      }
    }
LABEL_216:
    v134 = (int)&v386[2].dwCharacterID + 2;
    nCount = 0;
    nSlot2 = (int)&v386[2].dwCharacterID + 2;
    sValue._m_pStr = (char *)(-1090 - (_DWORD)v386);
    sKey._m_pStr = (char *)5;
    do
    {
      switch ( v108 )
      {
        case 0:
          v135 = 4;
          break;
        case 1:
          v135 = 8;
          break;
        case 2:
          v135 = 16;
          break;
        case 3:
          v135 = 32;
          break;
        case 4:
          v135 = 64;
          break;
        default:
          v135 = 0;
          break;
      }
      if ( (unsigned int)dbcharFlag & v135 )
      {
        v136 = *(_DWORD *)v134;
        if ( *(_DWORD *)v134 )
          v136 = *(_DWORD *)(v136 - 4);
        v137 = v136 - 1;
        v138 = 1;
        nTI = v136 - 1;
        if ( v136 - 1 >= 1 )
        {
          nSlot4 = (int)&sValue._m_pStr[v134];
          do
          {
            v139 = *(_DWORD *)v134 + 8 * v138;
            v140 = *(_DWORD *)(v139 + 4);
            if ( v140 && *(_QWORD *)(v140 + 24) )
            {
              v141 = *(_DWORD *)(v139 + 4);
              *(_DWORD *)pInfo.gap0 = &v382;
              *(_QWORD *)v383 = __PAIR__(v138, v141);
              if ( v141 )
                InterlockedIncrement((volatile LONG *)(v141 + 4));
              v142 = *(int *)((char *)&aaCashItem1[0].a + nSlot4);
              v143 = (_DWORD *)((char *)aaCashItem1 + nSlot4);
              LOBYTE(v408) = 10;
              if ( v142 )
                v144 = *(_DWORD *)(v142 - 4);
              else
                v144 = 0;
              if ( !v142 )
                goto LABEL_712;
              v145 = *(_DWORD *)(v142 - 8);
              if ( v145 < 0 )
                v145 = ~v145;
              if ( (v145 - 4) / 0xCu <= v144 )
              {
LABEL_712:
                v146 = 1;
                if ( v144 )
                  v146 = 2 * v144;
                ZArray<CashItemEntry>::_Reserve(
                  (ZArray<CashItemEntry> *)((char *)aaCashItem1 + nSlot4),
                  v146,
                  (ZAllocHelper *)&v387);
              }
              ++*(_DWORD *)(*v143 - 4);
              v147 = 12 * v144;
              memmove((char *)(v147 + *v143 + 12), (char *)(v147 + *v143), 0);
              v148 = v147 + *v143;
              if ( v148 )
                *(_DWORD *)(v148 + 4) = 0;
              v149 = (CashItemEntry *)(v147 + *v143);
              LOBYTE(v408) = 6;
              CashItemEntry::Set(v149, *(ZRef<GW_ItemSlotBase> *)&v382, (int)v383[1]);
              v137 = nTI;
              v134 = nSlot2;
            }
            ++v138;
          }
          while ( v138 <= v137 );
          v108 = nCount;
        }
      }
      ++v108;
      v134 += 4;
      v11 = sKey._m_pStr-- == (char *)1;
      nCount = v108;
      nSlot2 = v134;
    }
    while ( !v11 );
  }
  *(_DWORD *)pCore.gap0 = dbcharFlag & 0x80;
  sValue._m_pStr = 0;
  v150 = (CInPacket *)nSlotHyper;
  nCount = (int)&v386[2].dwCharacterID + 2;
  nSlot2 = 5;
  do
  {
    v151 = (ZArray<ZRef<GW_ItemSlotBase> > *)nCount;
    v152 = *(_DWORD *)nCount;
    if ( *(_DWORD *)nCount )
      v152 = *(_DWORD *)(v152 - 4);
    v153 = v152 - 1;
    sKey._m_pStr = (char *)(v152 - 1);
    if ( *(_DWORD *)pCore.gap0 )
    {
      v154 = CInPacket::Decode1(v150);
      v153 = v154;
      sKey._m_pStr = (char *)v154;
    }
    v155.a = v151->a;
    if ( v151->a )
      v155.a = (ZRef<GW_ItemSlotBase> *)v155.a[-1].p;
    if ( (ZRef<GW_ItemSlotBase> *)v153 != (ZRef<GW_ItemSlotBase> *)((char *)&v155.a[-1].p + 3) )
      ZArray<ZRef<GW_ItemSlotBase>>::_Realloc(v151, v153 + 1, 0, (ZAllocHelper *)&v387);
    switch ( (unsigned int)sValue._m_pStr )
    {
      case 0u:
        v156 = 4;
        break;
      case 1u:
        v156 = 8;
        break;
      case 2u:
        v156 = 16;
        break;
      case 3u:
        v156 = 32;
        break;
      case 4u:
        v156 = 64;
        break;
      default:
        v156 = 0;
        break;
    }
    if ( (unsigned int)dbcharFlag & v156 )
    {
      for ( i = 0; i <= (signed int)sKey._m_pStr; ++i )
      {
        v158 = *(_DWORD *)(*(_DWORD *)nCount + 8 * i + 4);
        v159 = *(_DWORD *)nCount + 8 * i;
        if ( v158 )
        {
          if ( !InterlockedDecrement((volatile LONG *)(v158 + 4)) )
          {
            InterlockedIncrement((volatile LONG *)(*(_DWORD *)(v159 + 4) + 4));
            v160 = *(void (__stdcall ****)(signed int))(v159 + 4);
            if ( v160 )
              (**v160)(1);
          }
          *(_DWORD *)(v159 + 4) = 0;
        }
      }
    }
    nCount += 4;
    ++sValue._m_pStr;
    --nSlot2;
  }
  while ( nSlot2 );
  if ( dbcharFlag & 0x100000 )
  {
    v161 = CInPacket::Decode4(v150);
    v162 = v386;
    *(_DWORD *)&v386[2].sCharacterName[10] = v161;
    *(_DWORD *)&v162[2].nSkin = CInPacket::Decode4(v150);
  }
  if ( dbcharFlag & 4 )
  {
    v387 = CInPacket::Decode1(v150) != 0;
    v163 = &v386[1].dwCharacterIDForLog;
    v164 = 32;
    do
    {
      if ( *v163 )
      {
        if ( !InterlockedDecrement((volatile LONG *)(*v163 + 4)) )
        {
          InterlockedIncrement((volatile LONG *)(*v163 + 4));
          if ( *v163 )
            (**(void (__stdcall ***)(signed int))*v163)(1);
        }
        *v163 = 0;
      }
      v163 += 2;
      --v164;
    }
    while ( v164 );
    v165 = CInPacket::Decode2(v150);
    v166 = v165;
    if ( v165 )
    {
      while ( 1 )
      {
        GW_ItemSlotBase::Decode((ZRef<GW_ItemSlotBase> *)&sValue, v150);
        LOBYTE(v408) = 11;
        if ( (unsigned int)(v166 - 1) <= 0x1E )
          break;
        LOBYTE(v408) = 6;
        if ( v385 )
        {
          if ( !InterlockedDecrement(&v385->_m_nRef) )
          {
            InterlockedIncrement(&v385->_m_nRef);
            if ( v385 )
              ((void (__stdcall *)(signed int))v385->vfptr->__vecDelDtor)(1);
          }
LABEL_300:
          v385 = 0;
        }
LABEL_301:
        v168 = CInPacket::Decode2(v150);
        v166 = v168;
        if ( !v168 )
          goto LABEL_302;
      }
      if ( bBackwardUpdate && v385->liCashItemSN.QuadPart )
      {
        v383[1] = (void *)-v166;
        v383[0] = v385;
        *(_DWORD *)pInfo.gap0 = &v382;
        if ( v385 )
          InterlockedIncrement(&v385->_m_nRef);
        LOBYTE(v408) = 12;
        v167 = ZArray<CashItemEntry>::InsertBefore(&aaCashItem2[1], -1);
        LOBYTE(v408) = 11;
        CashItemEntry::Set(v167, *(ZRef<GW_ItemSlotBase> *)&v382, (int)v383[1]);
      }
      else
      {
        ZRef<GW_ItemSlotBase>::operator=((ZRef<GW_ItemSlotBase> *)&v386[1] + v166, (ZRef<GW_ItemSlotBase> *)&sValue);
      }
      LOBYTE(v408) = 6;
      if ( !v385 )
        goto LABEL_301;
      if ( !InterlockedDecrement(&v385->_m_nRef) )
      {
        InterlockedIncrement(&v385->_m_nRef);
        if ( v385 )
          ((void (__stdcall *)(signed int))v385->vfptr->__vecDelDtor)(1);
      }
      goto LABEL_300;
    }
LABEL_302:
    v169 = v386[1]._ZtlSecureTear_nCharismaEXP;
    v170 = 32;
    do
    {
      if ( *v169 )
      {
        if ( !InterlockedDecrement((volatile LONG *)(*v169 + 4)) )
        {
          InterlockedIncrement((volatile LONG *)(*v169 + 4));
          if ( *v169 )
            (**(void (__stdcall ***)(signed int))*v169)(1);
        }
        *v169 = 0;
      }
      v169 += 2;
      --v170;
    }
    while ( v170 );
    v171 = CInPacket::Decode2(v150);
    v172 = v171;
    if ( v171 )
    {
      do
      {
        GW_ItemSlotBase::Decode((ZRef<GW_ItemSlotBase> *)&sValue, v150);
        LOBYTE(v408) = 13;
        if ( (unsigned int)(v172 - 1) <= 0x1E )
        {
          if ( bBackwardUpdate && GW_ItemSlotBase::IsCashItem(v385) )
          {
            v383[1] = (void *)(-100 - v172);
            *(_DWORD *)pInfo.gap0 = &v382;
            ZRef<GW_ItemSlotBase>::ZRef<GW_ItemSlotBase>(
              (ZRef<GW_ItemSlotBase> *)&v382,
              (ZRef<GW_ItemSlotBase> *)&sValue);
            LOBYTE(v408) = 14;
            v173 = ZArray<CashItemEntry>::InsertBefore(&aaCashItem2[1], -1);
            LOBYTE(v408) = 13;
            CashItemEntry::Set(v173, *(ZRef<GW_ItemSlotBase> *)&v382, (int)v383[1]);
          }
          else
          {
            ZRef<GW_ItemSlotBase>::operator=(
              (ZRef<GW_ItemSlotBase> *)&v386[1].nLastFatigueUpdateTime + v172,
              (ZRef<GW_ItemSlotBase> *)&sValue);
          }
        }
        LOBYTE(v408) = 6;
        ZRef<GW_ItemSlotBase>::~ZRef<GW_ItemSlotBase>((ZRef<GW_ItemSlotBase> *)&sValue);
        v174 = CInPacket::Decode2(v150);
        v172 = v174;
      }
      while ( v174 );
    }
    if ( !v387 )
    {
      v175 = *(unsigned int *)((char *)&v386[2].dwCharacterID + 2);
      if ( v175 )
        v175 = *(_DWORD *)(v175 - 4);
      sKey._m_pStr = (char *)(v175 - 1);
      v176 = CInPacket::Decode2(v150);
      v177 = v176;
      if ( v176 )
      {
        do
        {
          GW_ItemSlotBase::Decode((ZRef<GW_ItemSlotBase> *)&sValue, v150);
          LOBYTE(v408) = 15;
          if ( v177 >= 1 && v177 <= (signed int)sKey._m_pStr )
          {
            if ( bBackwardUpdate && GW_ItemSlotBase::IsCashItem(v385) )
            {
              v383[1] = (void *)v177;
              *(_DWORD *)pInfo.gap0 = &v382;
              ZRef<GW_ItemSlotBase>::ZRef<GW_ItemSlotBase>(
                (ZRef<GW_ItemSlotBase> *)&v382,
                (ZRef<GW_ItemSlotBase> *)&sValue);
              LOBYTE(v408) = 16;
              v178 = ZArray<CashItemEntry>::InsertBefore(&aaCashItem2[1], -1);
              LOBYTE(v408) = 15;
              CashItemEntry::Set(v178, *(ZRef<GW_ItemSlotBase> *)&v382, (int)v383[1]);
            }
            else
            {
              ZRef<GW_ItemSlotBase>::operator=(
                (ZRef<GW_ItemSlotBase> *)(*(unsigned int *)((char *)&v386[2].dwCharacterID + 2) + 8 * v177),
                (ZRef<GW_ItemSlotBase> *)&sValue);
            }
          }
          LOBYTE(v408) = 6;
          ZRef<GW_ItemSlotBase>::~ZRef<GW_ItemSlotBase>((ZRef<GW_ItemSlotBase> *)&sValue);
          v179 = CInPacket::Decode2(v150);
          v177 = v179;
        }
        while ( v179 );
      }
    }
    v180 = v386;
    NonBPEquip::Decode((NonBPEquip *)&v386[1].characterCard.card[7], v150, bBackwardUpdate, &aaCashItem2[1]);
    VirtualEquipInventory::Decode((VirtualEquipInventory *)&v180[1].stAccount_LastLogout.wMinute, v150, bBackwardUpdate);
  }
  nSlot4 = (int)&v386[2].dwCharacterIDForLog + 2;
  nTI = 2;
  sValue._m_pStr = (char *)(-1090 - (_DWORD)v386);
  do
  {
    v181 = get_item_type_from_typeindex(nTI);
    if ( dbcharFlag & v181 )
    {
      v182 = *(_DWORD *)nSlot4;
      if ( *(_DWORD *)nSlot4 )
        v182 = *(_DWORD *)(v182 - 4);
      sKey._m_pStr = (char *)(v182 - 1);
      v183 = CInPacket::Decode1(v150);
      v184 = v183;
      if ( v183 )
      {
        v185 = &sValue._m_pStr[nSlot4];
        do
        {
          GW_ItemSlotBase::Decode((ZRef<GW_ItemSlotBase> *)&nCount, v150);
          LOBYTE(v408) = 17;
          if ( v184 >= 1 && v184 <= (signed int)sKey._m_pStr )
          {
            if ( bBackwardUpdate && GW_ItemSlotBase::IsCashItem(v389) )
            {
              v383[1] = (void *)v184;
              *(_DWORD *)pInfo.gap0 = &v382;
              ZRef<GW_ItemSlotBase>::ZRef<GW_ItemSlotBase>(
                (ZRef<GW_ItemSlotBase> *)&v382,
                (ZRef<GW_ItemSlotBase> *)&nCount);
              LOBYTE(v408) = 18;
              v186 = ZArray<CashItemEntry>::InsertBefore(
                       (ZArray<CashItemEntry> *)((char *)aaCashItem2 + (_DWORD)v185),
                       -1);
              LOBYTE(v408) = 17;
              CashItemEntry::Set(v186, *(ZRef<GW_ItemSlotBase> *)&v382, (int)v383[1]);
            }
            else
            {
              ZRef<GW_ItemSlotBase>::operator=(
                (ZRef<GW_ItemSlotBase> *)(*(_DWORD *)nSlot4 + 8 * v184),
                (ZRef<GW_ItemSlotBase> *)&nCount);
            }
          }
          LOBYTE(v408) = 6;
          ZRef<GW_ItemSlotBase>::~ZRef<GW_ItemSlotBase>((ZRef<GW_ItemSlotBase> *)&nCount);
          v187 = CInPacket::Decode1(v150);
          v184 = v187;
        }
        while ( v187 );
      }
    }
    nSlot4 += 4;
    v133 = __OFSUB__(nTI + 1, 5);
    v11 = nTI == 4;
    v132 = nTI++ - 4 < 0;
  }
  while ( (unsigned __int8)(v132 ^ v133) | v11 );
  nTI = 2;
  do
  {
    v188 = get_item_type_from_typeindex(nTI);
    if ( dbcharFlag & v188 )
    {
      if ( nTI == 2 || nTI == 3 )
        v189 = 2;
      else
        v189 = nTI == 4 ? 7 : 0;
      for ( j = 0; j < v189; ++j )
      {
        *(_DWORD *)pInfo.gap0 = v383;
        CharacterData::SetBag((CharacterData *)v386, nTI, j, (ZRef<BagData>)(unsigned int)v383[0]);
      }
    }
    v133 = __OFSUB__(nTI + 1, 4);
    v11 = nTI == 3;
    v132 = nTI++ - 3 < 0;
  }
  while ( (unsigned __int8)(v132 ^ v133) | v11 );
  v191 = 2;
  nTI = 2;
  do
  {
    v192 = get_item_type_from_typeindex(v191);
    if ( dbcharFlag & v192 )
    {
      v193 = (char *)CInPacket::Decode4(v150);
      if ( (signed int)v193 > 0 )
      {
        sValue._m_pStr = v193;
        do
        {
          v194 = CInPacket::Decode4(v150);
          nCount = v194;
          if ( (unsigned int)(v191 - 2) <= 2 && v194 >= 0 )
          {
            if ( v191 == 2 || v191 == 3 )
              v195 = 2;
            else
              v195 = v191 == 4 ? 7 : 0;
            if ( v194 < v195 )
            {
              v395 = 0;
              ZRef<BagData>::_Alloc((ZRef<BagData> *)&nSlot2);
              v196 = v395;
              LOBYTE(v408) = 19;
              BagData::Decode(v395, v150);
              *(_DWORD *)pInfo.gap0 = v383;
              v383[1] = v196;
              if ( v196 )
                InterlockedIncrement((volatile LONG *)&v196[-1].aItemsInBag[10].p);
              CharacterData::SetBag((CharacterData *)v386, v191, nCount, *(ZRef<BagData> *)v383);
              LOBYTE(v408) = 6;
              if ( v196 )
              {
                v197 = (int)&v196[-1].aItemsInBag[10];
                if ( !InterlockedDecrement((volatile LONG *)(v197 + 4)) )
                {
                  InterlockedIncrement((volatile LONG *)(v197 + 4));
                  if ( v197 )
                    (**(void (__thiscall ***)(int, signed int))v197)(v197, 1);
                }
                v191 = nTI;
                v395 = 0;
              }
            }
          }
          --sValue._m_pStr;
        }
        while ( sValue._m_pStr );
      }
    }
    nTI = ++v191;
  }
  while ( v191 <= 4 );
  if ( (unsigned int)&off_1000000 & (unsigned int)dbcharFlag )
  {
    v198 = (ZMap<long,_FILETIME,long> *)((char *)&v386[2]._ZtlSecureTear_nSenseEXP[1] + 1);
    ZMap<long,_FILETIME,long>::RemoveAll((ZMap<long,_FILETIME,long> *)((char *)&v386[2]._ZtlSecureTear_nSenseEXP[1] + 1));
    v199 = CInPacket::Decode4(v150);
    if ( v199 > 0 )
    {
      v200 = v199;
      do
      {
        sValue._m_pStr = (char *)CInPacket::Decode4(v150);
        CInPacket::DecodeBuffer(v150, &pCore, 8u);
        ZMap<long,_FILETIME,long>::Insert(v198, (const int *)&sValue, (_FILETIME *)&pCore);
        --v200;
      }
      while ( v200 );
    }
  }
  if ( dbcharFlag & 0x40000000 )
  {
    v201 = (ZMap<unsigned __int64,_FILETIME,unsigned __int64> *)((char *)&v386[2].DayLimit.nWill + 1);
    ZMap<unsigned __int64,_FILETIME,unsigned __int64>::RemoveAll((ZMap<unsigned __int64,_FILETIME,unsigned __int64> *)((char *)&v386[2].DayLimit.nWill + 1));
    v202 = CInPacket::Decode4(v150);
    if ( v202 > 0 )
    {
      v203 = v202;
      do
      {
        *(_DWORD *)pInfo.gap0 = 0;
        pInfo.p = 0;
        CInPacket::DecodeBuffer(v150, &pInfo, 8u);
        CInPacket::DecodeBuffer(v150, &pCore, 8u);
        ZMap<unsigned __int64,_FILETIME,unsigned __int64>::Insert(
          v201,
          (const unsigned __int64 *)&pInfo,
          (_FILETIME *)&pCore);
        --v203;
      }
      while ( v203 );
    }
  }
  if ( dbcharFlag & 0x800000 )
  {
    nCount = (int)&v386[2].extendSP.lSPSet.vfptr + 1;
    sValue._m_pStr = (char *)4;
    do
    {
      v204 = *(_DWORD *)nCount;
      if ( *(_DWORD *)nCount )
      {
        v205 = (void (__thiscall ***)(_DWORD, signed int))(v204 - 16);
        v206 = (volatile LONG *)(v204 - 16 + 4);
        v383[1] = (void *)(v204 - 16 + 4);
        if ( !InterlockedDecrement((volatile LONG *)v383[1]) )
        {
          InterlockedIncrement(v206);
          if ( v205 )
            (**v205)(v205, 1);
        }
        *(_DWORD *)nCount = 0;
      }
      nCount += 8;
      --sValue._m_pStr;
    }
    while ( sValue._m_pStr );
    v207 = CInPacket::Decode1(v150);
    if ( v207 )
    {
      v208 = v386;
      do
      {
        GW_ItemPotSlot::Decode((ZRef<GW_ItemPotSlot> *)&pInfo, v150);
        LOBYTE(v408) = 20;
        if ( (unsigned __int8)(v207 - 1) <= 2u )
          ZRef<GW_ItemPotSlot>::operator=(
            (ZRef<GW_ItemPotSlot> *)((char *)&v208[2]._ZtlSecureTear_nWP_CS + 8 * v207 + 1),
            (ZRef<GW_ItemPotSlot> *)&pInfo);
        LOBYTE(v408) = 6;
        ZRef<GW_ItemPotSlot>::~ZRef<GW_ItemPotSlot>((ZRef<GW_ItemPotSlot> *)&pInfo);
        v207 = CInPacket::Decode1(v150);
      }
      while ( v207 );
    }
  }
  if ( dbcharFlag & 0x100 )
  {
    if ( CInPacket::Decode1(v150) )
    {
      v209 = CInPacket::Decode2(v150);
      v210 = v209;
      if ( v209 )
      {
        v211 = (ZMap<long,long,long> *)((char *)v386[2]._ZtlSecureTear_nEventPoint + 2);
        ZMap<long,long,long>::RemoveAll((ZMap<long,long,long> *)&v386[2].bBurning);
        ZMap<long,long,long>::RemoveAll(v211);
        ZMap<long,long,long>::RemoveAll(v211 + 1);
        for ( ; v210 > 0; --v210 )
        {
          v212 = (char *)CInPacket::Decode4(v150);
          sValue._m_pStr = v212;
          nCount = CInPacket::Decode4(v150);
          ZMap<long,long,long>::Insert((ZMap<long,long,long> *)&v386[2].bBurning, (const int *)&sValue, &nCount);
          CInPacket::DecodeBuffer(v150, &pCore, 8u);
          ZMap<long,_FILETIME,long>::Insert(
            (ZMap<long,_FILETIME,long> *)((char *)&v386[3]._ZtlSecureTear_nHP[1] + 3),
            (const int *)&sValue,
            (_FILETIME *)&pCore);
          if ( is_skill_need_master_level((int)v212) )
          {
            nCount = CInPacket::Decode4(v150);
            ZMap<long,long,long>::Insert(
              (ZMap<long,long,long> *)&v386[3].sCharacterName[7],
              (const int *)&sValue,
              &nCount);
          }
        }
      }
      v213 = (std::map<long,long,std::less<long>,std::allocator<std::pair<long const ,long> > > *)((char *)v386[5]._ZtlSecureTear_nSP
                                                                                                 + 1);
      std::_Tree<std::_Tmap_traits<long,long,std::less<long>,std::allocator<std::pair<long const,long>>,0>>::_Erase(
        (std::_Tree<std::_Tmap_traits<long,long,std::less<long>,std::allocator<std::pair<long const ,long> >,0> > *)((char *)v386[5]._ZtlSecureTear_nSP + 1),
        *(std::_Tree_nod<std::_Tmap_traits<long,long,std::less<long>,std::allocator<std::pair<long const ,long> >,0> >::_Node **)(*(unsigned int *)((char *)&v386[5]._ZtlSecureTear_nSP_CS + 1) + 4));
      v213->_Myhead->_Parent = v213->_Myhead;
      v214 = v213->_Myhead;
      v213->_Mysize = 0;
      v214->_Left = v214;
      v213->_Myhead->_Right = v213->_Myhead;
      v215 = (char *)(unsigned __int16)CInPacket::Decode2(v150);
      if ( (signed int)(unsigned __int16)v215 > 0 )
      {
        sValue._m_pStr = v215;
        do
        {
          nCount = CInPacket::Decode4(v150);
          v216 = (unsigned __int16)CInPacket::Decode2(v150);
          v217 = std::map<long,long,std::less<long>,std::allocator<std::pair<long const,long>>>::operator[](
                   v213,
                   &nCount);
          v11 = sValue._m_pStr-- == (char *)1;
          *v217 = v216;
        }
        while ( !v11 );
      }
    }
    else
    {
      v218 = (unsigned __int16)CInPacket::Decode2(v150);
      if ( v218 > 0 )
      {
        v219 = (DiffZMap<long,long,long> *)((char *)v386[2]._ZtlSecureTear_nEventPoint + 2);
        do
        {
          nTI = CInPacket::Decode4(v150);
          sValue._m_pStr = (char *)CInPacket::Decode4(v150);
          DiffZMap<long,long,long>::SetAt(v219, &nTI, (const int *)&sValue, 0);
          --v218;
        }
        while ( v218 > 0 );
      }
      v220 = (unsigned __int16)CInPacket::Decode2(v150);
      if ( v220 > 0 )
      {
        v221 = (DiffZMap<long,long,long> *)((char *)v386[2]._ZtlSecureTear_nEventPoint + 2);
        do
        {
          nTI = CInPacket::Decode4(v150);
          DiffZMap<long,long,long>::RemoveKey(v221, &nTI, 0);
          --v220;
        }
        while ( v220 > 0 );
      }
      pInfo = (ZRef<MONSTERLIFE_INVITEINFO>)DB_DATE_20790101_46;
      v222 = (unsigned __int16)CInPacket::Decode2(v150);
      if ( v222 > 0 )
      {
        v223 = (DiffZMap<long,_FILETIME,long> *)((char *)&v386[3]._ZtlSecureTear_nLevel_CS + 3);
        do
        {
          nTI = CInPacket::Decode4(v150);
          CInPacket::DecodeBuffer(v150, &pInfo, 8u);
          DiffZMap<long,_FILETIME,long>::SetAt(v223, &nTI, (_FILETIME *)&pInfo, 0);
          --v222;
        }
        while ( v222 > 0 );
      }
      v224 = (unsigned __int16)CInPacket::Decode2(v150);
      if ( v224 > 0 )
      {
        v225 = (DiffZMap<long,_FILETIME,long> *)((char *)&v386[3]._ZtlSecureTear_nLevel_CS + 3);
        do
        {
          nTI = CInPacket::Decode4(v150);
          DiffZMap<long,_FILETIME,long>::RemoveKey(v225, &nTI, 0);
          --v224;
        }
        while ( v224 > 0 );
      }
      v226 = (unsigned __int16)CInPacket::Decode2(v150);
      if ( v226 > 0 )
      {
        v227 = (DiffZMap<long,long,long> *)&v386[2].characterCard.card[7].nJob;
        do
        {
          nTI = CInPacket::Decode4(v150);
          sValue._m_pStr = (char *)CInPacket::Decode4(v150);
          DiffZMap<long,long,long>::SetAt(v227, &nTI, (const int *)&sValue, 0);
          --v226;
        }
        while ( v226 > 0 );
      }
      v228 = (unsigned __int16)CInPacket::Decode2(v150);
      if ( v228 > 0 )
      {
        v229 = (DiffZMap<long,long,long> *)&v386[2].characterCard.card[7].nJob;
        do
        {
          nTI = CInPacket::Decode4(v150);
          DiffZMap<long,long,long>::RemoveKey(v229, &nTI, 0);
          --v228;
        }
        while ( v228 > 0 );
      }
    }
  }
  v230 = (CharacterData *)v386;
  if ( dbcharFlag & 0x8000 )
  {
    ZMap<long,unsigned long,long>::RemoveAll((ZMap<long,unsigned long,long> *)((char *)&v386[3]._ZtlSecureTear_nMP[1] + 3));
    for ( k = (unsigned __int16)CInPacket::Decode2(v150); k > 0; --k )
    {
      nCount = CInPacket::Decode4(v150);
      sValue._m_pStr = (char *)CInPacket::Decode4(v150);
      ZMap<long,unsigned long,long>::Insert(&v230->mSkillCooltime, &nCount, (const unsigned int *)&sValue);
    }
  }
  if ( dbcharFlag & 0x200 )
  {
    v232 = CInPacket::Decode1(v150);
    LOBYTE(nSlot2) = v232 != 0;
    if ( v232 )
    {
      ZMap<long,ZXString<char>,long>::RemoveAll(&v230->mQuestRecord);
      ZList<long>::RemoveAll(&v230->lQuestRecordModified);
      ZList<long>::RemoveAll(&v230->lQuestRecordDeleted);
    }
    v233 = (unsigned __int16)CInPacket::Decode2(v150);
    if ( (signed int)(unsigned __int16)v233 > 0 )
    {
      nCount = v233;
      do
      {
        v234 = CInPacket::Decode4(v150);
        CInPacket::DecodeStr(v150, &sValue);
        LOBYTE(v408) = 21;
        CharacterData::SetQuest(v230, v234, &sValue, nSlot2);
        LOBYTE(v408) = 6;
        if ( sValue._m_pStr )
        {
          v235 = sValue._m_pStr - 12;
          if ( InterlockedDecrement((volatile LONG *)sValue._m_pStr - 3) <= 0 )
            ZAllocEx<ZAllocStrSelector<char>>::Free(&ZAllocEx<ZAllocStrSelector<char>>::_s_alloc, v235);
        }
        --nCount;
      }
      while ( nCount );
    }
    if ( !(_BYTE)nSlot2 )
    {
      v236 = (unsigned __int16)CInPacket::Decode2(v150);
      if ( v236 > 0 )
      {
        do
        {
          v237 = CInPacket::Decode4(v150);
          CharacterData::RemoveQuest(v230, v237);
          --v236;
        }
        while ( v236 );
      }
    }
  }
  if ( dbcharFlag & 0x4000 )
  {
    v238 = CInPacket::Decode1(v150);
    v387 = v238 != 0;
    if ( v238 )
      ZMap<long,_FILETIME,long>::RemoveAll(&v230->mQuestComplete);
    v239 = (char *)(unsigned __int16)CInPacket::Decode2(v150);
    if ( (_WORD)v239 )
    {
      sValue._m_pStr = v239;
      do
      {
        v240 = CInPacket::Decode4(v150);
        nCount = v240;
        CInPacket::DecodeBuffer(v150, &pCore, 8u);
        if ( v387 )
          ZMap<long,_FILETIME,long>::Insert(&v230->mQuestComplete, &nCount, (_FILETIME *)&pCore);
        else
          CharacterData::SetQuestComplete(v230, v240, (_FILETIME *)&pCore);
        --sValue._m_pStr;
      }
      while ( sValue._m_pStr );
    }
    if ( !v387 )
    {
      v241 = (unsigned __int16)CInPacket::Decode2(v150);
      if ( (_WORD)v241 )
      {
        v242 = (std::_Tree<std::_Tset_traits<long,std::less<long>,std::allocator<long>,0> > *)&v230->setQuestCompleteModified.comp;
        nSlot2 = (int)&v230->mQuestComplete;
        nCount = (int)&v230->setQuestCompleteDeleted;
        v243 = v241;
        do
        {
          sValue._m_pStr = (char *)CInPacket::Decode4(v150);
          std::_Tree<std::_Tset_traits<long,std::less<long>,std::allocator<long>,0>>::erase(v242, (const int *)&sValue);
          std::_Tree<std::_Tset_traits<long,std::less<long>,std::allocator<long>,0>>::insert(
            (std::_Tree<std::_Tset_traits<long,std::less<long>,std::allocator<long>,0> > *)nCount,
            (std::pair<std::_Tree<std::_Tset_traits<long,std::less<long>,std::allocator<long>,0> >::iterator,bool> *)&pCore,
            (const int *)&sValue);
          ZMap<long,_FILETIME,long>::RemoveKey((ZMap<long,_FILETIME,long> *)nSlot2, (const int *)&sValue);
          --v243;
        }
        while ( v243 );
      }
    }
  }
  if ( dbcharFlag & 0x400 )
  {
    for ( sValue._m_pStr = (char *)(unsigned __int16)CInPacket::Decode2(v150);
          (signed int)sValue._m_pStr > 0;
          --sValue._m_pStr )
    {
      pInfo.p = 0;
      LOBYTE(v408) = 22;
      ZRef<GW_MiniGameRecord>::_Alloc((ZRef<GW_MiniGameRecord> *)&pInfo);
      v244 = CInPacket::Decode4(v150);
      v245 = pInfo.p;
      pInfo.p->dwOwnerAID = v244;
      v245->sOwnerName._m_pStr = (char *)CInPacket::Decode4(v150);
      *(_DWORD *)&v245->lRewardGradeQ._Alnod.0 = CInPacket::Decode4(v150);
      v245->lRewardGradeQ._Myhead = (std::_List_nod<unsigned char,std::allocator<unsigned char> >::_Node *)CInPacket::Decode4(v150);
      v246 = CInPacket::Decode4(v150);
      v247 = v386;
      v245->lRewardGradeQ._Mysize = v246;
      ZMap<long,ZRef<GW_MiniGameRecord>,long>::Insert(
        (ZMap<long,ZRef<GW_MiniGameRecord>,long> *)v247[3]._ZtlSecureTear_nSenseEXP,
        (const int *)v245,
        (ZRef<GW_MiniGameRecord> *)&pInfo);
      v248 = (int)&v245[-1].sOwnerName;
      LOBYTE(v408) = 6;
      if ( !InterlockedDecrement((volatile LONG *)(v248 + 4)) )
      {
        InterlockedIncrement((volatile LONG *)(v248 + 4));
        if ( v248 )
          (**(void (__thiscall ***)(int, signed int))v248)(v248, 1);
      }
      pInfo.p = 0;
    }
  }
  if ( dbcharFlag & 0x800 )
  {
    if ( bBackwardUpdate )
    {
      for ( l = (unsigned __int16)CInPacket::Decode2(v150); l > 0; --l )
        CInPacket::DecodeBuffer(v150, &dummyBLD, 0x21u);
      for ( m = (unsigned __int16)CInPacket::Decode2(v150); m > 0; --m )
        CInPacket::DecodeBuffer(v150, &dummyBLD, 0x25u);
      for ( n = (unsigned __int16)CInPacket::Decode2(v150); n > 0; --n )
        CInPacket::DecodeBuffer(v150, &dummyBLD, 0x30u);
    }
    else
    {
      v252 = (ZList<GW_CoupleRecord> *)((char *)&v386[3]._ZtlSecureTear_nPvPExp[1] + 3);
      ZList<GW_CoupleRecord>::RemoveAll((ZList<GW_CoupleRecord> *)((char *)&v386[3]._ZtlSecureTear_nPvPExp[1] + 3));
      for ( ii = (unsigned __int16)CInPacket::Decode2(v150); ii > 0; --ii )
      {
        v254 = ZList<GW_CoupleRecord>::AddTail(v252);
        CInPacket::DecodeBuffer(v150, v254, 0x21u);
      }
      v255 = (ZList<GW_FriendRecord> *)((char *)&v386[3]._ZtlSecureTear_nPvPPoint_CS + 1);
      ZList<GW_FriendRecord>::RemoveAll((ZList<GW_FriendRecord> *)((char *)&v386[3]._ZtlSecureTear_nPvPPoint_CS + 1));
      for ( jj = (unsigned __int16)CInPacket::Decode2(v150); jj > 0; --jj )
      {
        v257 = ZList<GW_FriendRecord>::AddTail(v255);
        CInPacket::DecodeBuffer(v150, v257, 0x25u);
      }
      v258 = (ZList<GW_MarriageRecord> *)((char *)&v386[3]._ZtlSecureTear_nEventPoint[1] + 1);
      ZList<GW_MarriageRecord>::RemoveAll((ZList<GW_MarriageRecord> *)((char *)&v386[3]._ZtlSecureTear_nEventPoint[1] + 1));
      for ( kk = (unsigned __int16)CInPacket::Decode2(v150); kk > 0; --kk )
      {
        v260 = ZList<GW_MarriageRecord>::AddTail(v258);
        CInPacket::DecodeBuffer(v150, v260, 0x30u);
      }
    }
  }
  if ( dbcharFlag & 0x1000 )
  {
    v261 = (unsigned int *)((char *)&v386[3].ftAlbaStartTime.dwHighDateTime + 3);
    v262 = 5;
    do
    {
      *v261 = CInPacket::Decode4(v150);
      ++v261;
      --v262;
    }
    while ( v262 );
    v263 = (int *)((char *)&v386[3]._ZtlSecureTear_bAlbaSpecialReward[1] + 3);
    v264 = 10;
    do
    {
      *v263 = CInPacket::Decode4(v150);
      ++v263;
      --v264;
    }
    while ( v264 );
    v265 = &v386[3].characterCard.card[3].nLevel;
    v266 = 13;
    do
    {
      *(_DWORD *)v265 = CInPacket::Decode4(v150);
      v265 += 4;
      --v266;
    }
    while ( v266 );
  }
  if ( bBackwardUpdate )
  {
    nTI = 1;
    while ( 1 )
    {
      v267 = &aaCashItem2[nTI];
      v268 = &aaCashItem1[nTI];
      nSlot4 = 0;
      if ( (signed int)ZArray<CashItemEntry>::GetCount(&aaCashItem2[nTI]) > 0 )
      {
        sKey._m_pStr = 0;
        nSlot2 = 1;
        nCount = 12;
        do
        {
          v269 = nSlot2;
          sValue._m_pStr = (char *)nSlot2;
          if ( v269 < (signed int)ZArray<CashItemEntry>::GetCount(v267) )
          {
            v270.a = v267->a;
            v271 = *(_DWORD *)&sKey._m_pStr[(unsigned int)v267->a + 4];
            v272 = *(_DWORD *)(v271 + 24);
            v273 = *(_DWORD *)(v271 + 28);
            v403 = v272;
            v404 = v273;
            v274 = (int)&v270.a->pItem.p + nCount;
            do
            {
              if ( v403 == *(_DWORD *)(*(_DWORD *)v274 + 24) && v404 == *(_DWORD *)(*(_DWORD *)v274 + 28) )
                break;
              ++sValue._m_pStr;
              v274 += 12;
              v275 = ZArray<CashItemEntry>::GetCount(v267);
            }
            while ( (signed int)sValue._m_pStr < v275 );
          }
          v276 = ZArray<CashItemEntry>::GetCount(v267);
          if ( (signed int)sValue._m_pStr >= v276 )
          {
            v278 = 0;
            if ( (signed int)ZArray<CashItemEntry>::GetCount(v268) > 0 )
            {
              v279.a = v268->a;
              v280 = *(_DWORD *)&sKey._m_pStr[(unsigned int)aaCashItem2[nTI].a + 4];
              v281 = *(GW_Core **)(v280 + 28);
              *(_DWORD *)pCore.gap0 = *(_DWORD *)(v280 + 24);
              pCore.p = v281;
              v282 = (int)&v279.a->pItem.p;
              do
              {
                if ( *(_DWORD *)pCore.gap0 == *(_DWORD *)(*(_DWORD *)v282 + 24)
                  && pCore.p == *(GW_Core **)(*(_DWORD *)v282 + 28) )
                {
                  break;
                }
                ++v278;
                v282 += 12;
              }
              while ( v278 < (signed int)ZArray<CashItemEntry>::GetCount(v268) );
            }
            if ( v278 < (signed int)ZArray<CashItemEntry>::GetCount(v268) )
            {
              v283 = 3 * v278;
              v284 = nTI;
              v283 *= 4;
              (*(void (__stdcall **)(_DWORD))(**(_DWORD **)((char *)&v268->a->pItem.p + v283) + 288))(*(_DWORD *)&sKey._m_pStr[(unsigned int)aaCashItem2[nTI].a + 4]);
              ZRef<GW_ItemSlotBase>::operator=(
                (ZRef<GW_ItemSlotBase> *)&sKey._m_pStr[(unsigned int)aaCashItem2[v284].a],
                (ZRef<GW_ItemSlotBase> *)((char *)&v268->a->pItem + v283));
              ZArray<CashItemEntry>::RemoveAt(v268, (__POSITION *)&v268->a->pItem.gap0[v283]);
            }
          }
          else
          {
            v277 = sKey._m_pStr;
            ZArray<CashItemEntry>::RemoveAt(v267, (__POSITION *)&sKey._m_pStr[(unsigned int)v267->a]);
            nCount -= 12;
            --nSlot4;
            --nSlot2;
            sKey._m_pStr = v277 - 12;
          }
          ++nSlot2;
          nCount += 12;
          sKey._m_pStr += 12;
          v267 = &aaCashItem2[nTI];
          v285 = ++nSlot4;
        }
        while ( v285 < (signed int)ZArray<CashItemEntry>::GetCount(&aaCashItem2[nTI]) );
      }
      if ( v268->a && v268->a[-1].nPOS && (nSlot4 = 0, (signed int)ZArray<CashItemEntry>::GetCount(v268) > 0) )
      {
        v286 = nTI;
        sValue._m_pStr = 0;
        do
        {
          v287 = &v268->a->pItem.gap0[(unsigned int)sValue._m_pStr];
          v383[1] = (void *)(*((_DWORD *)v287 + 1) + 24);
          if ( !`anonymous namespace'::IsExist_((ZArray<_LARGE_INTEGER> *)&nKey, (_LARGE_INTEGER *)v383[1]) )
          {
            v288 = ZArray<CashItemEntry>::InsertBefore(&aaCashItem2[nTI], -1);
            ZRef<GW_ItemSlotBase>::operator=(&v288->pItem, (ZRef<GW_ItemSlotBase> *)v287);
            v288->nPOS = *((_DWORD *)v287 + 2);
            v286 = nTI;
          }
          sValue._m_pStr += 12;
          v289 = ++nSlot4;
        }
        while ( v289 < (signed int)ZArray<CashItemEntry>::GetCount(v268) );
      }
      else
      {
        v286 = nTI;
      }
      v290 = (CharacterData *)v386;
      v291 = &aaCashItem2[v286];
      nSlot4 = 0;
      if ( (signed int)ZArray<CashItemEntry>::GetCount(&aaCashItem2[v286]) > 0 )
        break;
LABEL_537:
      nTI = v286 + 1;
      if ( v286 + 1 > 5 )
        goto LABEL_538;
    }
    sValue._m_pStr = 0;
    while ( 1 )
    {
      v292 = &sValue._m_pStr[(unsigned int)v291->a];
      v293 = CharacterData::GetItemSlotCount(v290, v286);
      if ( v286 != 1 || (v294 = *((_DWORD *)v292 + 2), v294 > -101) || v294 < -131 )
      {
        v296 = *((_DWORD *)v292 + 2);
        if ( v296 < 1 || v296 > v293 )
        {
          v298 = -v296;
          if ( (unsigned int)(v298 - 1300) <= 4
            || (unsigned int)(v298 - 1200) <= 6
            || (unsigned int)(v298 - 1500) <= 0xB )
          {
            v299 = 0;
            do
            {
              if ( (unsigned int)v299 <= 6 && v298 >= NonBPEquip::anBasePOS[v299] && v298 < NonBPEquip::anEndPOS[v299] )
                break;
              ++v299;
            }
            while ( v299 < 7 );
            if ( !v290->nonBPEquipped.aEquip[v299].a[v298 - NonBPEquip::anBasePOS[v299]].p )
            {
              v300 = *((_DWORD *)v292 + 1);
              *(_DWORD *)pInfo.gap0 = &v382;
              *(_QWORD *)v383 = __PAIR__(v298, v300);
              if ( v300 )
                InterlockedIncrement((volatile LONG *)(v300 + 4));
              NonBPEquip::SetItem(&v290->nonBPEquipped, *(ZRef<GW_ItemSlotBase> *)&v382, (int)v383[1]);
              goto LABEL_536;
            }
          }
LABEL_532:
          v301 = CharacterData::FindEmptySlotPosition(v290, v286);
          v383[1] = v292;
          if ( v301 <= 0 )
            v295 = ZArray<ZRef<GW_ItemSlotBase>>::InsertBefore(&v290->aaItemSlot[v286], -1);
          else
            v295 = &v290->aaItemSlot[v286].a[v301];
          goto LABEL_535;
        }
        v297 = v290->aaItemSlot[v286].a;
        v11 = v297[v296].p == 0;
        v295 = &v297[v296];
        if ( !v11 )
          goto LABEL_532;
        v383[1] = v292;
      }
      else
      {
        v295 = (ZRef<GW_ItemSlotBase> *)((char *)&v290->characterStat.dwCharacterID - 8 * v294 + 2);
        if ( v295->p )
          goto LABEL_532;
        v383[1] = v292;
      }
LABEL_535:
      ZRef<GW_ItemSlotBase>::operator=(v295, (ZRef<GW_ItemSlotBase> *)v383[1]);
LABEL_536:
      ++nSlot4;
      sValue._m_pStr += 12;
      v291 = &aaCashItem2[v286];
      v302 = ZArray<CashItemEntry>::GetCount(&aaCashItem2[v286]);
      if ( nSlot4 >= v302 )
        goto LABEL_537;
    }
  }
LABEL_538:
  v303 = (CInPacket *)nSlotHyper;
  if ( dbcharFlag & 0x40000 )
  {
    v304 = CInPacket::Decode2((CInPacket *)nSlotHyper);
    v305 = v386;
    nCount = v304;
    if ( (signed int)v304 > 0 )
    {
      do
      {
        v306 = CInPacket::Decode4(v303);
        CInPacket::DecodeStr(v303, &sValue);
        nSlot2 = v306;
        v307 = sValue._m_pStr;
        LOBYTE(v408) = 23;
        v308 = ZMap<long,CSimpleStrMap,long>::Insert(
                 (ZMap<long,CSimpleStrMap,long> *)((char *)&v305[4]._ZtlSecureTear_nMoney[1] + 6),
                 &nSlot2,
                 0);
        CSimpleStrMap::InitFromRawString((CSimpleStrMap *)&v308[12], v307);
        LOBYTE(v408) = 6;
        if ( sValue._m_pStr )
        {
          v309 = sValue._m_pStr - 12;
          if ( InterlockedDecrement((volatile LONG *)sValue._m_pStr - 3) <= 0 )
            ZAllocEx<ZAllocStrSelector<char>>::Free(&ZAllocEx<ZAllocStrSelector<char>>::_s_alloc, v309);
        }
        --nCount;
      }
      while ( nCount > 0 );
    }
  }
  else
  {
    v305 = v386;
  }
  if ( dbcharFlag & 0x200000000000i64 )
  {
    for ( ll = (unsigned __int16)CInPacket::Decode2(v303); ll > 0; LOBYTE(v408) = 6 )
    {
      sValue._m_pStr = (char *)CInPacket::Decode4(v303);
      value._m_nRef = 0;
      value._m_pPrev = 0;
      value.vfptr = (ZRefCountedVtbl *)&AvatarLook::`vftable';
      AvatarLook::Initialize(&value);
      LOBYTE(v408) = 24;
      AvatarLook::Decode(&value, v303);
      ZMap<long,AvatarLook,long>::Insert(
        (ZMap<long,AvatarLook,long> *)((char *)&v305[4]._ZtlSecureTear_nMHP_CS + 2),
        (const int *)&sValue,
        &value);
      --ll;
    }
  }
  v311 = CInPacket::Decode1(v303);
  *(int *)((char *)&v305[4]._ZtlSecureTear_nCharismaEXP[1] + 2) = v311;
  if ( v311 )
  {
    if ( dbcharFlag & 0x10000000000i64 )
    {
      for ( nCount = CInPacket::Decode4(v303); nCount > 0; --nCount )
      {
        v312 = CInPacket::Decode4(v303);
        CInPacket::DecodeStr(v303, &sValue);
        nSlot2 = v312;
        v313 = sValue._m_pStr;
        LOBYTE(v408) = 25;
        v314 = ZMap<long,CSimpleStrMap,long>::Insert(
                 (ZMap<long,CSimpleStrMap,long> *)((char *)&v305[4]._ZtlSecureTear_nCharismaEXP_CS + 2),
                 &nSlot2,
                 0);
        CSimpleStrMap::InitFromRawString((CSimpleStrMap *)&v314[12], v313);
        LOBYTE(v408) = 6;
        if ( sValue._m_pStr )
        {
          v315 = sValue._m_pStr - 12;
          if ( InterlockedDecrement((volatile LONG *)sValue._m_pStr - 3) <= 0 )
            ZAllocEx<ZAllocStrSelector<char>>::Free(&ZAllocEx<ZAllocStrSelector<char>>::_s_alloc, v315);
        }
      }
    }
  }
  if ( dbcharFlag & 0x100000000000i64 )
  {
    for ( mm = CInPacket::Decode4(v303); mm > 0; --mm )
    {
      nCount = CInPacket::Decode4(v303);
      sValue._m_pStr = (char *)CInPacket::Decode4(v303);
      ZMap<unsigned long,int,unsigned long>::Insert(
        (ZMap<unsigned long,int,unsigned long> *)((char *)&v305[4]._ZtlSecureTear_nWillEXP_CS + 2),
        (const unsigned int *)&nCount,
        (const int *)&sValue);
    }
  }
  if ( dbcharFlag & 0x200000 )
  {
    v383[1] = (void *)v305->_ZtlSecureTear_nJob_CS;
    if ( _ZtlSecureFuse<short>(v305->_ZtlSecureTear_nJob, (unsigned int)v383[1]) / 100 == 33 )
    {
      v317 = CharacterData::GetWildHunterInfo((CharacterData *)v305, (ZRef<GW_WildHunterInfo> *)&pCore)->p;
      LOBYTE(v408) = 26;
      GW_WildHunterInfo::Decode(v317, v303);
      LOBYTE(v408) = 6;
      if ( pCore.p )
      {
        v318 = &pCore.p[-1].4;
        v383[1] = &pCore.p[-1].4 + 1;
        if ( !InterlockedDecrement((volatile LONG *)v383[1]) )
        {
          InterlockedIncrement(&v318[1]._m_nRef);
          if ( v318 )
            (*(void (__thiscall **)($71D4F1BB3D693B543BB6351DD48CDF34 *, signed int))v318->_m_nRef)(v318, 1);
        }
      }
    }
  }
  if ( dbcharFlag & 0x80000000000i64 )
  {
    v383[1] = (void *)v305->_ZtlSecureTear_nJob_CS;
    v319 = _ZtlSecureFuse<short>(v305->_ZtlSecureTear_nJob, (unsigned int)v383[1]);
    if ( (signed __int16)v319 == 10000 || v319 == 10100 || v319 == 10110 || v319 == 10111 || v319 == 10112 )
    {
      if ( !*(unsigned int *)((char *)&v305[4]._ZtlSecureTear_nDEX_CS + 2) )
        ZRef<ZeroInfo>::_Alloc((ZRef<ZeroInfo> *)&v305[4]._ZtlSecureTear_nDEX[1]);
      ZeroInfo::Decode(*(ZeroInfo **)((char *)&v305[4]._ZtlSecureTear_nDEX_CS + 2), v303, bBackwardUpdate);
    }
  }
  CharacterData::InitAdditionalItemEffect((CharacterData *)v305);
  v11 = (dbcharFlag & 0x4000000) == 0;
  *(unsigned int *)((char *)&v305[5]._ZtlSecureTear_nMMP_CS + 1) = 0;
  if ( !v11 )
  {
    v320 = CInPacket::Decode2(v303);
    v321 = v320;
    nCount = v320;
    ZMap<long,ZRef<GW_NpcShopBuyLimit>,long>::RemoveAll((ZMap<long,ZRef<GW_NpcShopBuyLimit>,long> *)&v305[3].DayLimit);
    if ( v321 > 0 )
    {
      do
      {
        sValue._m_pStr = (char *)(unsigned __int16)CInPacket::Decode2(v303);
        v322 = CInPacket::Decode4(v303);
        v323 = v322;
        if ( sValue._m_pStr && v322 )
        {
          pInfo.p = 0;
          ZRef<GW_NpcShopBuyLimit>::_Alloc((ZRef<GW_NpcShopBuyLimit> *)&pInfo);
          LOBYTE(v408) = 27;
          if ( pInfo.p )
          {
            pInfo.p->dwOwnerAID = v323;
            nSlot2 = v323;
            ZMap<long,ZRef<GW_NpcShopBuyLimit>,long>::Insert(
              (ZMap<long,ZRef<GW_NpcShopBuyLimit>,long> *)&v305[3].DayLimit,
              &nSlot2,
              (ZRef<GW_NpcShopBuyLimit> *)&pInfo);
          }
          for ( ; (signed int)sValue._m_pStr > 0; --sValue._m_pStr )
          {
            v397 = 0;
            ZRef<BuyLimitData>::_Alloc((ZRef<BuyLimitData> *)&sKey);
            v324 = v397;
            LOBYTE(v408) = 28;
            if ( v397 )
            {
              *(_DWORD *)v324 = CInPacket::Decode4(v303);
              *(_WORD *)(v324 + 4) = CInPacket::Decode2(v303);
              *(_DWORD *)(v324 + 6) = CInPacket::Decode4(v303);
              v325 = CInPacket::Decode2(v303);
              v383[1] = (void *)8;
              *(_DWORD *)(v324 + 10) = v325;
              CInPacket::DecodeBuffer(v303, (void *)(v324 + 14), (unsigned int)v383[1]);
              if ( !*(_DWORD *)(v324 + 6) || !*(_DWORD *)v324 )
              {
                LOBYTE(v408) = 27;
LABEL_589:
                v326 = v324 - 16;
                if ( !InterlockedDecrement((volatile LONG *)(v326 + 4)) )
                {
                  InterlockedIncrement((volatile LONG *)(v326 + 4));
                  if ( v326 )
                    (**(void (__thiscall ***)(int, signed int))v326)(v326, 1);
                }
                v397 = 0;
                continue;
              }
              if ( pInfo.p )
              {
                nSlot2 = *(unsigned __int16 *)(v324 + 4);
                ZMap<long,ZRef<BuyLimitData>,long>::Insert(
                  (ZMap<long,ZRef<BuyLimitData>,long> *)&pInfo.p->sOwnerName,
                  &nSlot2,
                  (ZRef<BuyLimitData> *)&sKey);
              }
            }
            else
            {
              dummyBLD.ftDate = DB_DATE_19000101_45;
              dummyBLD.dwNPCID = CInPacket::Decode4(v303);
              dummyBLD.nItemIndex = CInPacket::Decode2(v303);
              dummyBLD.nItemID = CInPacket::Decode4(v303);
              dummyBLD.nCount = (unsigned __int16)CInPacket::Decode2(v303);
              CInPacket::DecodeBuffer(v303, &dummyBLD.ftDate, 8u);
            }
            LOBYTE(v408) = 27;
            if ( v324 )
              goto LABEL_589;
          }
          LOBYTE(v408) = 6;
          if ( pInfo.p )
          {
            v327 = (char *)&pInfo.p[-1].sOwnerName;
            v328 = (volatile LONG *)&pInfo.p[-1].lRewardGradeQ;
            v383[1] = &pInfo.p[-1].lRewardGradeQ;
            if ( !InterlockedDecrement((volatile LONG *)v383[1]) )
            {
              InterlockedIncrement(v328);
              if ( v327 )
                (**(void (__thiscall ***)(char *, signed int))v327)(v327, 1);
            }
            pInfo.p = 0;
          }
        }
        v305 = v386;
        --nCount;
      }
      while ( nCount > 0 );
    }
  }
  if ( dbcharFlag & 0x20000000 )
  {
    *(unsigned int *)((char *)&v305[3]._ZtlSecureTear_nPOP_CS + 3) = 0;
    *(_DWORD *)((char *)v305[3]._ZtlSecureTear_nMoney + 3) = 0;
    *(_DWORD *)((char *)v305[3]._ZtlSecureTear_nMoney + 7) = 0;
    *(_DWORD *)((char *)&v305[3]._ZtlSecureTear_nMoney[1] + 3) = 0;
    *(_DWORD *)((char *)&v305[3]._ZtlSecureTear_nMoney[1] + 7) = 0;
    *(unsigned int *)((char *)&v305[3]._ZtlSecureTear_nMoney_CS + 3) = 0;
    *(int *)((char *)v305[3]._ZtlSecureTear_nWP + 3) = 0;
    *(int *)((char *)&v305[3]._ZtlSecureTear_nWP[1] + 3) = 0;
    *(unsigned int *)((char *)&v305[3]._ZtlSecureTear_nWP_CS + 3) = 0;
    *(ZList<SPSet>Vtbl **)((char *)&v305[3].extendSP.lSPSet.vfptr + 3) = 0;
    *(_DWORD *)&v305[3].extendSP.lSPSet.gap4[3] = 0;
    *(unsigned int *)((char *)&v305[3].extendSP.lSPSet._m_uCount + 3) = 0;
    *(SPSet **)((char *)&v305[3].extendSP.lSPSet._m_pHead + 3) = 0;
    *(SPSet **)((char *)&v305[3].extendSP.lSPSet._m_pTail + 3) = 0;
    *(int *)((char *)&v305[3].extendSP.m_nTotalSP + 3) = 0;
    *(unsigned int *)((char *)&v305[3].dwPosMap.FakePtr1 + 3) = 0;
    *(unsigned int *)((char *)&v305[3].dwPosMap.FakePtr2 + 3) = 0;
    *(TSecData<unsigned long> **)((char *)&v305[3].dwPosMap.m_secdata + 3) = 0;
    v305[3].nDefFaceAcc = 0;
    *(_DWORD *)&v305[3].nFatigue = 0;
    sValue._m_pStr = (char *)1;
    do
    {
      v329 = 0;
      sKey._m_pStr = (char *)get_steal_memory_maxsize((int)sValue._m_pStr);
      if ( (signed int)sKey._m_pStr > 0 )
      {
        do
        {
          nSlot2 = CInPacket::Decode4(v303);
          nCount = 0;
          if ( ZMap<long,long,long>::GetAt((ZMap<long,long,long> *)&v305[2].bBurning, &nSlot2, &nCount) && nCount > 0 )
            *(_DWORD *)((char *)&v305[3]._ZtlSecureTear_nEXP64[1] + 4 * (v329 + 4 * (_DWORD)sValue._m_pStr) + 7) = nSlot2;
          ++v329;
        }
        while ( v329 < (signed int)sKey._m_pStr );
      }
      v133 = __OFSUB__(sValue._m_pStr + 1, 6);
      v132 = (_DWORD)(sValue._m_pStr++ - 5) < 0;
    }
    while ( v132 ^ v133 );
  }
  if ( dbcharFlag & 0x10000000 )
  {
    ZMap<long,long,long>::RemoveAll((ZMap<long,long,long> *)((char *)&v305[3]._ZtlSecureTear_nAP_CS + 3));
    sValue._m_pStr = (char *)CInPacket::Decode4(v303);
    nSlot2 = CInPacket::Decode4(v303);
    sKey._m_pStr = (char *)CInPacket::Decode4(v303);
    nSlot4 = CInPacket::Decode4(v303);
    nSlotHyper = CInPacket::Decode4(v303);
    nCount = 24001001;
    ZMap<long,long,long>::Insert(
      (ZMap<long,long,long> *)((char *)&v305[3]._ZtlSecureTear_nAP_CS + 3),
      &nCount,
      (const int *)&sValue);
    sValue._m_pStr = (_BYTE *)(&loc_16FC086 + 3);
    ZMap<long,long,long>::Insert(
      (ZMap<long,long,long> *)((char *)&v305[3]._ZtlSecureTear_nAP_CS + 3),
      (const int *)&sValue,
      &nSlot2);
    sValue._m_pStr = (char *)&loc_16FE799;
    ZMap<long,long,long>::Insert(
      (ZMap<long,long,long> *)((char *)&v305[3]._ZtlSecureTear_nAP_CS + 3),
      (const int *)&sValue,
      (const int *)&sKey);
    sValue._m_pStr = (_BYTE *)(&off_1700EA8 + 1);
    ZMap<long,long,long>::Insert(
      (ZMap<long,long,long> *)((char *)&v305[3]._ZtlSecureTear_nAP_CS + 3),
      (const int *)&sValue,
      &nSlot4);
    sValue._m_pStr = (char *)&loc_1700EDD + 1;
    ZMap<long,long,long>::Insert(
      (ZMap<long,long,long> *)((char *)&v305[3]._ZtlSecureTear_nAP_CS + 3),
      (const int *)&sValue,
      &nSlotHyper);
  }
  if ( (dbcharFlag & 0x80000000) != 0i64 )
  {
    std::_Tree<std::_Tmap_traits<unsigned char,GW_CharacterPotentialSkill,std::less<unsigned char>,std::allocator<std::pair<unsigned char const,GW_CharacterPotentialSkill>>,0>>::_Erase(
      (std::_Tree<std::_Tmap_traits<unsigned char,GW_CharacterPotentialSkill,std::less<unsigned char>,std::allocator<std::pair<unsigned char const ,GW_CharacterPotentialSkill> >,0> > *)((char *)&v305[3]._ZtlSecureTear_nCharismaEXP_CS + 3),
      *(std::_Tree_nod<std::_Tmap_traits<unsigned char,GW_CharacterPotentialSkill,std::less<unsigned char>,std::allocator<std::pair<unsigned char const ,GW_CharacterPotentialSkill> >,0> >::_Node **)(*(int *)((char *)v305[3]._ZtlSecureTear_nInsightEXP + 3) + 4));
    *(_DWORD *)(*(int *)((char *)v305[3]._ZtlSecureTear_nInsightEXP + 3) + 4) = *(int *)((char *)v305[3]._ZtlSecureTear_nInsightEXP
                                                                                       + 3);
    v330 = *(_DWORD **)((char *)v305[3]._ZtlSecureTear_nInsightEXP + 3);
    *(int *)((char *)&v305[3]._ZtlSecureTear_nInsightEXP[1] + 3) = 0;
    *v330 = v330;
    *(_DWORD *)(*(int *)((char *)v305[3]._ZtlSecureTear_nInsightEXP + 3) + 8) = *(int *)((char *)v305[3]._ZtlSecureTear_nInsightEXP
                                                                                       + 3);
    v331 = (char *)(unsigned __int16)CInPacket::Decode2(v303);
    if ( (signed int)(unsigned __int16)v331 > 0 )
    {
      sValue._m_pStr = v331;
      do
      {
        BYTE1(pInfo.p) = CInPacket::Decode1(v303);
        *(_DWORD *)pInfo.gap0 = CInPacket::Decode4(v303);
        LOBYTE(pInfo.p) = CInPacket::Decode1(v303);
        BYTE2(pInfo.p) = CInPacket::Decode1(v303);
        v332 = std::map<unsigned char,GW_CharacterPotentialSkill,std::less<unsigned char>,std::allocator<std::pair<unsigned char const,GW_CharacterPotentialSkill>>>::operator[](
                 (std::map<unsigned char,GW_CharacterPotentialSkill,std::less<unsigned char>,std::allocator<std::pair<unsigned char const ,GW_CharacterPotentialSkill> > > *)((char *)&v305[3]._ZtlSecureTear_nCharismaEXP_CS + 3),
                 (const char *)&pInfo.p + 1);
        v11 = sValue._m_pStr-- == (char *)1;
        v333 = (__int16)pInfo.p;
        v332->nSkillID = *(_DWORD *)pInfo.gap0;
        v334 = BYTE2(pInfo.p);
        *(_WORD *)&v332->nSkillLevel = v333;
        v332->nGrade = v334;
      }
      while ( !v11 );
    }
  }
  if ( dbcharFlag & 0x1000000000000i64 )
  {
    ZMap<long,ZRef<GW_SoulCollection>,long>::RemoveAll((ZMap<long,ZRef<GW_SoulCollection>,long> *)((char *)&v305[5]._ZtlSecureTear_nWP_CS
                                                                                                 + 1));
    v335 = (char *)(unsigned __int16)CInPacket::Decode2(v303);
    if ( (signed int)(unsigned __int16)v335 > 0 )
    {
      sValue._m_pStr = v335;
      do
      {
        pInfo.p = 0;
        ZRef<GW_SoulCollection>::_Alloc((ZRef<GW_SoulCollection> *)&pInfo);
        v336 = pInfo.p;
        LOBYTE(v408) = 29;
        LOWORD(v336->lRewardGradeQ._Myhead) = CInPacket::Decode4(v303);
        *(std::_List_nod<unsigned char,std::allocator<unsigned char> >::_Node **)((char *)&v336->lRewardGradeQ._Myhead
                                                                                + 2) = (std::_List_nod<unsigned char,std::allocator<unsigned char> >::_Node *)CInPacket::Decode4(v303);
        nCount = SLOWORD(v336->lRewardGradeQ._Myhead);
        ZMap<long,ZRef<GW_SoulCollection>,long>::Insert(
          (ZMap<long,ZRef<GW_SoulCollection>,long> *)((char *)&v305[5]._ZtlSecureTear_nWP_CS + 1),
          &nCount,
          (ZRef<GW_SoulCollection> *)&pInfo);
        LOBYTE(v408) = 6;
        if ( !InterlockedDecrement((volatile LONG *)&v336->sOwnerName) )
        {
          InterlockedIncrement((volatile LONG *)&v336->sOwnerName);
          (*(void (__thiscall **)(MONSTERLIFE_INVITEINFO *, signed int))v336->dwOwnerAID)(v336, 1);
        }
        v11 = sValue._m_pStr-- == (char *)1;
        pInfo.p = 0;
      }
      while ( !v11 );
    }
  }
  std::_Tree<std::_Tmap_traits<ZXString<char>,ZRef<MONSTERLIFE_INVITEINFO>,std::less<ZXString<char>>,std::allocator<std::pair<ZXString<char> const,ZRef<MONSTERLIFE_INVITEINFO>>>,0>>::_Erase(
    (std::_Tree<std::_Tmap_traits<ZXString<char>,ZRef<MONSTERLIFE_INVITEINFO>,std::less<ZXString<char> >,std::allocator<std::pair<ZXString<char> const ,ZRef<MONSTERLIFE_INVITEINFO> > >,0> > *)((char *)v305[3]._ZtlSecureTear_nWillEXP + 3),
    *(std::_Tree_nod<std::_Tmap_traits<ZXString<char>,ZRef<MONSTERLIFE_INVITEINFO>,std::less<ZXString<char> >,std::allocator<std::pair<ZXString<char> const ,ZRef<MONSTERLIFE_INVITEINFO> > >,0> >::_Node **)(*(int *)((char *)&v305[3]._ZtlSecureTear_nWillEXP[1] + 3) + 4));
  *(_DWORD *)(*(int *)((char *)&v305[3]._ZtlSecureTear_nWillEXP[1] + 3) + 4) = *(int *)((char *)&v305[3]._ZtlSecureTear_nWillEXP[1]
                                                                                      + 3);
  v337 = *(_DWORD **)((char *)&v305[3]._ZtlSecureTear_nWillEXP[1] + 3);
  *(unsigned int *)((char *)&v305[3]._ZtlSecureTear_nWillEXP_CS + 3) = 0;
  *v337 = v337;
  *(_DWORD *)(*(int *)((char *)&v305[3]._ZtlSecureTear_nWillEXP[1] + 3) + 8) = *(int *)((char *)&v305[3]._ZtlSecureTear_nWillEXP[1]
                                                                                      + 3);
  v338 = (char *)CInPacket::Decode4(v303);
  if ( (signed int)v338 > 0 )
  {
    sValue._m_pStr = v338;
    do
    {
      sKey._m_pStr = 0;
      LOBYTE(v408) = 30;
      v339 = CInPacket::DecodeStr(v303, (ZXString<char> *)&nCount);
      LOBYTE(v408) = 31;
      ZXString<char>::operator=(&sKey, v339);
      LOBYTE(v408) = 30;
      if ( nCount )
      {
        v340 = (void *)(nCount - 12);
        if ( InterlockedDecrement((volatile LONG *)(nCount - 12)) <= 0 )
          ZAllocEx<ZAllocStrSelector<char>>::Free(&ZAllocEx<ZAllocStrSelector<char>>::_s_alloc, v340);
      }
      pInfo.p = 0;
      LOBYTE(v408) = 32;
      ZRef<MONSTERLIFE_INVITEINFO>::_Alloc(&pInfo);
      v341 = pInfo.p;
      MONSTERLIFE_INVITEINFO::DecodeMonsterLifeInviteInfo(pInfo.p, v303);
      if ( sKey._m_pStr )
      {
        if ( *sKey._m_pStr )
        {
          if ( v341 )
          {
            if ( v341->dwOwnerAID )
            {
              v342 = v341->sOwnerName._m_pStr;
              if ( v342 )
              {
                if ( *v342 && v341->lRewardGradeQ._Mysize )
                {
                  v383[1] = &pInfo;
                  v343 = std::map<ZXString<char>,ZRef<MONSTERLIFE_INVITEINFO>,std::less<ZXString<char>>,std::allocator<std::pair<ZXString<char> const,ZRef<MONSTERLIFE_INVITEINFO>>>>::operator[](
                           (std::map<ZXString<char>,ZRef<MONSTERLIFE_INVITEINFO>,std::less<ZXString<char> >,std::allocator<std::pair<ZXString<char> const ,ZRef<MONSTERLIFE_INVITEINFO> > > > *)((char *)v305[3]._ZtlSecureTear_nWillEXP + 3),
                           &sKey);
                  ZRef<MONSTERLIFE_INVITEINFO>::operator=(v343, (ZRef<MONSTERLIFE_INVITEINFO> *)v383[1]);
                }
              }
            }
          }
        }
      }
      LOBYTE(v408) = 30;
      if ( v341 )
      {
        v344 = (int)&v341[-1].sOwnerName;
        if ( !InterlockedDecrement((volatile LONG *)(v344 + 4)) )
        {
          InterlockedIncrement((volatile LONG *)(v344 + 4));
          if ( v344 )
            (**(void (__thiscall ***)(int, signed int))v344)(v344, 1);
        }
        pInfo.p = 0;
      }
      LOBYTE(v408) = 6;
      if ( sKey._m_pStr )
      {
        v345 = sKey._m_pStr - 12;
        if ( InterlockedDecrement((volatile LONG *)sKey._m_pStr - 3) <= 0 )
          ZAllocEx<ZAllocStrSelector<char>>::Free(&ZAllocEx<ZAllocStrSelector<char>>::_s_alloc, v345);
      }
      --sValue._m_pStr;
    }
    while ( sValue._m_pStr );
  }
  HIBYTE(v305[3]._ZtlSecureTear_nCraftEXP[0]) = 0;
  v346 = CInPacket::Decode1(v303);
  v347 = BYTE4(dbcharFlag);
  HIBYTE(v305[3]._ZtlSecureTear_nCraftEXP[0]) = v346;
  if ( v347 & 1 )
  {
    v305[3]._ZtlSecureTear_nCraftEXP[1] = CInPacket::Decode4(v303);
    v305[3]._ZtlSecureTear_nCraftEXP_CS = CInPacket::Decode4(v303);
  }
  if ( v347 & 2 )
  {
    if ( CInPacket::Decode1(v303) )
    {
      ZMap<long,ZMap<long,long,long>,long>::RemoveAll((ZMap<long,ZMap<long,long,long>,long> *)((char *)&v305[5].nHair + 1));
      sValue._m_pStr = (char *)(unsigned __int16)CInPacket::Decode2(v303);
      if ( (signed int)sValue._m_pStr > 0 )
      {
        do
        {
          v348 = CInPacket::Decode2(v303);
          v349 = (unsigned __int16)CInPacket::Decode2(v303);
          if ( v349 > 0 )
          {
            nCount = v348;
            do
            {
              v350 = CInPacket::Decode4(v303);
              v351 = CInPacket::Decode4(v303);
              CharacterData::SetEntryRecord((CharacterData *)v386, nCount, v350, v351);
              --v349;
            }
            while ( v349 > 0 );
          }
          --sValue._m_pStr;
        }
        while ( (signed int)sValue._m_pStr > 0 );
        v305 = v386;
      }
    }
    else
    {
      for ( sValue._m_pStr = (char *)(unsigned __int16)CInPacket::Decode2(v303);
            (signed int)sValue._m_pStr > 0;
            --sValue._m_pStr )
      {
        nCount = (unsigned __int16)CInPacket::Decode2(v303);
        v352 = CInPacket::Decode4(v303);
        v353 = CInPacket::Decode4(v303);
        nCount = (unsigned __int16)nCount;
        CharacterData::SetEntryRecord((CharacterData *)v305, (unsigned __int16)nCount, v352, v353);
        CharacterData::SetERModified((CharacterData *)v305, (std::pair<long,long>)__PAIR__(v352, nCount));
      }
    }
  }
  v354 = BYTE4(dbcharFlag);
  if ( dbcharFlag & 0x400000000i64 )
    ReturnEffectInfo::Decode((ReturnEffectInfo *)v305[5]._ZtlSecureTear_nLUK, v303);
  if ( v354 & 8 )
    GW_DressUpInfo::Decode((GW_DressUpInfo *)&v305[5]._ZtlSecureTear_nHP[1], v303);
  if ( v354 & 0x10 )
  {
    v355 = (CharacterData *)v386;
    v356 = *(_DWORD *)((char *)v386[5]._ZtlSecureTear_nAP + 1);
    if ( !v356 || *(_DWORD *)(v356 - 4) < 0xAu )
      ZArray<ZRef<GW_Core>>::_Alloc(
        (ZArray<ZRef<GW_Core> > *)((char *)v386[5]._ZtlSecureTear_nAP + 1),
        0xAu,
        (ZAllocHelper *)&v387);
    v357 = v355->m_aCoreInven.a;
    if ( !v357 || v357[-1].p < (GW_Core *)0x60 )
      ZArray<ZRef<GW_Core>>::_Alloc(&v355->m_aCoreInven, 0x60u, (ZAllocHelper *)&v387);
    v358 = 0;
    do
    {
      *(_DWORD *)pInfo.gap0 = v383;
      CharacterData::SetCore(v355, 0, v358++, (ZRef<GW_Core>)(unsigned int)v383[0]);
    }
    while ( v358 < 10 );
    v359 = 0;
    do
    {
      *(_DWORD *)pInfo.gap0 = v383;
      CharacterData::SetCore(v355, 1, v359++, (ZRef<GW_Core>)(unsigned int)v383[0]);
    }
    while ( v359 < 96 );
    v360 = (char *)(unsigned __int16)CInPacket::Decode2(v303);
    if ( (signed int)(unsigned __int16)v360 > 0 )
    {
      sValue._m_pStr = v360;
      do
      {
        nCount = (unsigned __int16)CInPacket::Decode2(v303);
        pCore.p = 0;
        ZRef<GW_Core>::_Alloc(&pCore);
        LOBYTE(v408) = 33;
        v361 = CInPacket::Decode4(v303);
        v362 = pCore.p;
        pCore.p->nCoreID = v361;
        v362->nLeftCount = CInPacket::Decode4(v303);
        *(_DWORD *)pInfo.gap0 = v383;
        v383[1] = v362;
        InterlockedIncrement(&v362->_m_nRef);
        CharacterData::SetCore((CharacterData *)v386, 0, nCount, *(ZRef<GW_Core> *)v383);
        LOBYTE(v408) = 6;
        if ( !InterlockedDecrement(&v362->_m_nRef) )
        {
          InterlockedIncrement(&v362->_m_nRef);
          v362->vfptr->__vecDelDtor((ZRefCounted *)&v362->vfptr, 1u);
        }
        v11 = sValue._m_pStr-- == (char *)1;
        pCore.p = 0;
      }
      while ( !v11 );
    }
    v363 = (char *)(unsigned __int16)CInPacket::Decode2(v303);
    if ( (signed int)(unsigned __int16)v363 > 0 )
    {
      sValue._m_pStr = v363;
      do
      {
        nCount = (unsigned __int16)CInPacket::Decode2(v303);
        pCore.p = 0;
        ZRef<GW_Core>::_Alloc(&pCore);
        LOBYTE(v408) = 34;
        v364 = CInPacket::Decode4(v303);
        v365 = pCore.p;
        pCore.p->nCoreID = v364;
        v365->nLeftCount = CInPacket::Decode4(v303);
        *(_DWORD *)pInfo.gap0 = v383;
        v383[1] = v365;
        InterlockedIncrement(&v365->_m_nRef);
        CharacterData::SetCore((CharacterData *)v386, 1, nCount, *(ZRef<GW_Core> *)v383);
        LOBYTE(v408) = 6;
        if ( !InterlockedDecrement(&v365->_m_nRef) )
        {
          InterlockedIncrement(&v365->_m_nRef);
          v365->vfptr->__vecDelDtor((ZRefCounted *)&v365->vfptr, 1u);
        }
        v11 = sValue._m_pStr-- == (char *)1;
        pCore.p = 0;
      }
      while ( !v11 );
    }
  }
  v366 = HIDWORD(dbcharFlag);
  v367 = v386;
  if ( dbcharFlag & 0x2000000000i64 )
    FARM_POTENTIAL::Decode((FARM_POTENTIAL *)((char *)&v386[3]._ZtlSecureTear_nInsightEXP_CS + 3), v303);
  if ( v366 & 0x40 )
  {
    FarmUserInfo::Decode((FarmUserInfo *)((char *)&v367[2]._ZtlSecureTear_nMP_CS + 2), v303);
    v367[2]._ZtlSecureTear_nWP[0] = CInPacket::Decode4(v303);
    v367[2]._ZtlSecureTear_nWP[1] = CInPacket::Decode4(v303);
  }
  if ( v366 & 0x80 )
    MemorialCubeInfo::Decode((MemorialCubeInfo *)((char *)&v367[5]._ZtlSecureTear_nMP[1] + 1), v303);
  if ( v366 & 0x400 )
  {
    v368 = CInPacket::Decode4(v303);
    v383[1] = (void *)8;
    v383[0] = (char *)&v367[5]._ZtlSecureTear_nEXP64[1] + 1;
    *(_DWORD *)((char *)v367[5]._ZtlSecureTear_nEXP64 + 5) = v368;
    CInPacket::DecodeBuffer(v303, v383[0], (unsigned int)v383[1]);
    *(unsigned int *)((char *)&v367[5]._ZtlSecureTear_nEXP64_CS + 1) = CInPacket::Decode4(v303);
  }
  if ( v366 & 0x20000 )
    RunnerGameRecord::Decode((RunnerGameRecord *)&v367[4]._ZtlSecureTear_nPvPGrade[1], v303);
  nCount = (unsigned __int16)CInPacket::Decode2(v303);
  if ( nCount > 0 )
  {
    v369 = (ZMap<long,CSimpleStrMap,long> *)&v367[4].extendSP.lSPSet.gap4[2];
    do
    {
      v370 = CInPacket::Decode4(v303);
      CInPacket::DecodeStr(v303, &sValue);
      nSlot2 = v370;
      v371 = sValue._m_pStr;
      LOBYTE(v408) = 35;
      v372 = ZMap<long,CSimpleStrMap,long>::Insert(v369, &nSlot2, 0);
      CSimpleStrMap::InitFromRawString((CSimpleStrMap *)&v372[12], v371);
      LOBYTE(v408) = 6;
      if ( sValue._m_pStr )
      {
        v373 = sValue._m_pStr - 12;
        if ( InterlockedDecrement((volatile LONG *)sValue._m_pStr - 3) <= 0 )
          ZAllocEx<ZAllocStrSelector<char>>::Free(&ZAllocEx<ZAllocStrSelector<char>>::_s_alloc, v373);
      }
      --nCount;
    }
    while ( nCount > 0 );
    v366 = HIDWORD(dbcharFlag);
  }
  if ( v366 & 0x40000 )
  {
    nCount = (unsigned __int16)CInPacket::Decode2(v303);
    if ( nCount > 0 )
    {
      v374 = (ZMap<long,CSimpleStrMap,long> *)((char *)&v386[4].dwPosMap.FakePtr2 + 2);
      do
      {
        v375 = CInPacket::Decode4(v303);
        CInPacket::DecodeStr(v303, &sValue);
        nSlot2 = v375;
        v376 = sValue._m_pStr;
        LOBYTE(v408) = 36;
        v377 = ZMap<long,CSimpleStrMap,long>::Insert(v374, &nSlot2, 0);
        CSimpleStrMap::InitFromRawString((CSimpleStrMap *)&v377[12], v376);
        LOBYTE(v408) = 6;
        if ( sValue._m_pStr )
        {
          v378 = sValue._m_pStr - 12;
          if ( InterlockedDecrement((volatile LONG *)sValue._m_pStr - 3) <= 0 )
            ZAllocEx<ZAllocStrSelector<char>>::Free(&ZAllocEx<ZAllocStrSelector<char>>::_s_alloc, v378);
        }
        --nCount;
      }
      while ( nCount > 0 );
    }
  }
  v379 = (CharacterData *)v386;
  *(unsigned int *)((char *)&v386[5]._ZtlSecureTear_nMMP_CS + 1) = 0;
  v380 = CInPacket::Decode1(v303);
  v383[1] = v303;
  v379->m_bFarmOnline = v380 != 0;
  CharacterData::DecodeTextEquipInfo(v379, (CInPacket *)v383[1]);
  LOBYTE(v408) = 5;
  `eh vector destructor iterator'(
    aaCashItem2,
    4u,
    6,
    (void (__thiscall *)(void *))ZArray<CashItemEntry>::~ZArray<CashItemEntry>);
  LOBYTE(v408) = 0;
  `eh vector destructor iterator'(
    aaCashItem1,
    4u,
    6,
    (void (__thiscall *)(void *))ZArray<CashItemEntry>::~ZArray<CashItemEntry>);
  v408 = -1;
  if ( nKey )
    ZAllocEx<ZAllocAnonSelector>::Free(&ZAllocEx<ZAllocAnonSelector>::_s_alloc, (void *)(nKey - 4));
  return dbcharFlag;
}
